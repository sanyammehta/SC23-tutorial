


















/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::lockRemoteNode_5_closure : public SDAG::Closure {
            int impl_noname_0;
            int impl_noname_1;
            int impl_noname_2;
            int impl_noname_3;


      lockRemoteNode_5_closure() {
        init();
      }
      lockRemoteNode_5_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_0;}
            int & getP1() { return impl_noname_1;}
            int & getP2() { return impl_noname_2;}
            int & getP3() { return impl_noname_3;}
      void pup(PUP::er& __p) {
        __p | impl_noname_0;
        __p | impl_noname_1;
        __p | impl_noname_2;
        __p | impl_noname_3;
        packClosure(__p);
      }
      virtual ~lockRemoteNode_5_closure() {
      }
      PUPable_decl(SINGLE_ARG(lockRemoteNode_5_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::unlockRemoteNode_6_closure : public SDAG::Closure {
            int impl_noname_4;
            int impl_noname_5;
            int impl_noname_6;
            int impl_noname_7;


      unlockRemoteNode_6_closure() {
        init();
      }
      unlockRemoteNode_6_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_4;}
            int & getP1() { return impl_noname_5;}
            int & getP2() { return impl_noname_6;}
            int & getP3() { return impl_noname_7;}
      void pup(PUP::er& __p) {
        __p | impl_noname_4;
        __p | impl_noname_5;
        __p | impl_noname_6;
        __p | impl_noname_7;
        packClosure(__p);
      }
      virtual ~unlockRemoteNode_6_closure() {
      }
      PUPable_decl(SINGLE_ARG(unlockRemoteNode_6_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::removeGhostNode_15_closure : public SDAG::Closure {
            int fromChk;
            int sharedIdx;


      removeGhostNode_15_closure() {
        init();
      }
      removeGhostNode_15_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return fromChk;}
            int & getP1() { return sharedIdx;}
      void pup(PUP::er& __p) {
        __p | fromChk;
        __p | sharedIdx;
        packClosure(__p);
      }
      virtual ~removeGhostNode_15_closure() {
      }
      PUPable_decl(SINGLE_ARG(removeGhostNode_15_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::refine_flip_element_leb_16_closure : public SDAG::Closure {
            int impl_noname_8;
            int impl_noname_9;
            int impl_noname_a;
            int impl_noname_b;
            int impl_noname_c;
            int impl_noname_d;
            double impl_noname_e;


      refine_flip_element_leb_16_closure() {
        init();
      }
      refine_flip_element_leb_16_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_8;}
            int & getP1() { return impl_noname_9;}
            int & getP2() { return impl_noname_a;}
            int & getP3() { return impl_noname_b;}
            int & getP4() { return impl_noname_c;}
            int & getP5() { return impl_noname_d;}
            double & getP6() { return impl_noname_e;}
      void pup(PUP::er& __p) {
        __p | impl_noname_8;
        __p | impl_noname_9;
        __p | impl_noname_a;
        __p | impl_noname_b;
        __p | impl_noname_c;
        __p | impl_noname_d;
        __p | impl_noname_e;
        packClosure(__p);
      }
      virtual ~refine_flip_element_leb_16_closure() {
      }
      PUPable_decl(SINGLE_ARG(refine_flip_element_leb_16_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::addToSharedList_17_closure : public SDAG::Closure {
            int impl_noname_f;
            int impl_noname_10;


      addToSharedList_17_closure() {
        init();
      }
      addToSharedList_17_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_f;}
            int & getP1() { return impl_noname_10;}
      void pup(PUP::er& __p) {
        __p | impl_noname_f;
        __p | impl_noname_10;
        packClosure(__p);
      }
      virtual ~addToSharedList_17_closure() {
      }
      PUPable_decl(SINGLE_ARG(addToSharedList_17_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::getRemoteCoord_19_closure : public SDAG::Closure {
            int impl_noname_11;
            int impl_noname_12;


      getRemoteCoord_19_closure() {
        init();
      }
      getRemoteCoord_19_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_11;}
            int & getP1() { return impl_noname_12;}
      void pup(PUP::er& __p) {
        __p | impl_noname_11;
        __p | impl_noname_12;
        packClosure(__p);
      }
      virtual ~getRemoteCoord_19_closure() {
      }
      PUPable_decl(SINGLE_ARG(getRemoteCoord_19_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::getRemoteBound_20_closure : public SDAG::Closure {
            int impl_noname_13;
            int impl_noname_14;


      getRemoteBound_20_closure() {
        init();
      }
      getRemoteBound_20_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_13;}
            int & getP1() { return impl_noname_14;}
      void pup(PUP::er& __p) {
        __p | impl_noname_13;
        __p | impl_noname_14;
        packClosure(__p);
      }
      virtual ~getRemoteBound_20_closure() {
      }
      PUPable_decl(SINGLE_ARG(getRemoteBound_20_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::getIdxGhostSend_21_closure : public SDAG::Closure {
            int impl_noname_15;
            int impl_noname_16;
            int impl_noname_17;


      getIdxGhostSend_21_closure() {
        init();
      }
      getIdxGhostSend_21_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_15;}
            int & getP1() { return impl_noname_16;}
            int & getP2() { return impl_noname_17;}
      void pup(PUP::er& __p) {
        __p | impl_noname_15;
        __p | impl_noname_16;
        __p | impl_noname_17;
        packClosure(__p);
      }
      virtual ~getIdxGhostSend_21_closure() {
      }
      PUPable_decl(SINGLE_ARG(getIdxGhostSend_21_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::updateIdxlList_22_closure : public SDAG::Closure {
            int impl_noname_18;
            int impl_noname_19;
            int impl_noname_1a;


      updateIdxlList_22_closure() {
        init();
      }
      updateIdxlList_22_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_18;}
            int & getP1() { return impl_noname_19;}
            int & getP2() { return impl_noname_1a;}
      void pup(PUP::er& __p) {
        __p | impl_noname_18;
        __p | impl_noname_19;
        __p | impl_noname_1a;
        packClosure(__p);
      }
      virtual ~updateIdxlList_22_closure() {
      }
      PUPable_decl(SINGLE_ARG(updateIdxlList_22_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::removeIDXLRemote_23_closure : public SDAG::Closure {
            int impl_noname_1b;
            int impl_noname_1c;
            int impl_noname_1d;


      removeIDXLRemote_23_closure() {
        init();
      }
      removeIDXLRemote_23_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_1b;}
            int & getP1() { return impl_noname_1c;}
            int & getP2() { return impl_noname_1d;}
      void pup(PUP::er& __p) {
        __p | impl_noname_1b;
        __p | impl_noname_1c;
        __p | impl_noname_1d;
        packClosure(__p);
      }
      virtual ~removeIDXLRemote_23_closure() {
      }
      PUPable_decl(SINGLE_ARG(removeIDXLRemote_23_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::addTransIDXLRemote_24_closure : public SDAG::Closure {
            int impl_noname_1e;
            int impl_noname_1f;
            int impl_noname_20;


      addTransIDXLRemote_24_closure() {
        init();
      }
      addTransIDXLRemote_24_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_1e;}
            int & getP1() { return impl_noname_1f;}
            int & getP2() { return impl_noname_20;}
      void pup(PUP::er& __p) {
        __p | impl_noname_1e;
        __p | impl_noname_1f;
        __p | impl_noname_20;
        packClosure(__p);
      }
      virtual ~addTransIDXLRemote_24_closure() {
      }
      PUPable_decl(SINGLE_ARG(addTransIDXLRemote_24_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::verifyIdxlList_25_closure : public SDAG::Closure {
            int impl_noname_21;
            int impl_noname_22;
            int impl_noname_23;


      verifyIdxlList_25_closure() {
        init();
      }
      verifyIdxlList_25_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_21;}
            int & getP1() { return impl_noname_22;}
            int & getP2() { return impl_noname_23;}
      void pup(PUP::er& __p) {
        __p | impl_noname_21;
        __p | impl_noname_22;
        __p | impl_noname_23;
        packClosure(__p);
      }
      virtual ~verifyIdxlList_25_closure() {
      }
      PUPable_decl(SINGLE_ARG(verifyIdxlList_25_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::idxllockRemote_26_closure : public SDAG::Closure {
            int impl_noname_24;
            int impl_noname_25;


      idxllockRemote_26_closure() {
        init();
      }
      idxllockRemote_26_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_24;}
            int & getP1() { return impl_noname_25;}
      void pup(PUP::er& __p) {
        __p | impl_noname_24;
        __p | impl_noname_25;
        packClosure(__p);
      }
      virtual ~idxllockRemote_26_closure() {
      }
      PUPable_decl(SINGLE_ARG(idxllockRemote_26_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::idxlunlockRemote_27_closure : public SDAG::Closure {
            int impl_noname_26;
            int impl_noname_27;


      idxlunlockRemote_27_closure() {
        init();
      }
      idxlunlockRemote_27_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_26;}
            int & getP1() { return impl_noname_27;}
      void pup(PUP::er& __p) {
        __p | impl_noname_26;
        __p | impl_noname_27;
        packClosure(__p);
      }
      virtual ~idxlunlockRemote_27_closure() {
      }
      PUPable_decl(SINGLE_ARG(idxlunlockRemote_27_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::eatIntoElement_28_closure : public SDAG::Closure {
            int impl_noname_28;
            int impl_noname_29;


      eatIntoElement_28_closure() {
        init();
      }
      eatIntoElement_28_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_28;}
            int & getP1() { return impl_noname_29;}
      void pup(PUP::er& __p) {
        __p | impl_noname_28;
        __p | impl_noname_29;
        packClosure(__p);
      }
      virtual ~eatIntoElement_28_closure() {
      }
      PUPable_decl(SINGLE_ARG(eatIntoElement_28_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::getLockOwner_29_closure : public SDAG::Closure {
            int impl_noname_2a;
            int impl_noname_2b;


      getLockOwner_29_closure() {
        init();
      }
      getLockOwner_29_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_2a;}
            int & getP1() { return impl_noname_2b;}
      void pup(PUP::er& __p) {
        __p | impl_noname_2a;
        __p | impl_noname_2b;
        packClosure(__p);
      }
      virtual ~getLockOwner_29_closure() {
      }
      PUPable_decl(SINGLE_ARG(getLockOwner_29_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::knowsAbtNode_30_closure : public SDAG::Closure {
            int impl_noname_2c;
            int impl_noname_2d;
            int impl_noname_2e;


      knowsAbtNode_30_closure() {
        init();
      }
      knowsAbtNode_30_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_2c;}
            int & getP1() { return impl_noname_2d;}
            int & getP2() { return impl_noname_2e;}
      void pup(PUP::er& __p) {
        __p | impl_noname_2c;
        __p | impl_noname_2d;
        __p | impl_noname_2e;
        packClosure(__p);
      }
      virtual ~knowsAbtNode_30_closure() {
      }
      PUPable_decl(SINGLE_ARG(knowsAbtNode_30_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::hasLockRemoteNode_31_closure : public SDAG::Closure {
            int impl_noname_2f;
            int impl_noname_30;
            int impl_noname_31;


      hasLockRemoteNode_31_closure() {
        init();
      }
      hasLockRemoteNode_31_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_2f;}
            int & getP1() { return impl_noname_30;}
            int & getP2() { return impl_noname_31;}
      void pup(PUP::er& __p) {
        __p | impl_noname_2f;
        __p | impl_noname_30;
        __p | impl_noname_31;
        packClosure(__p);
      }
      virtual ~hasLockRemoteNode_31_closure() {
      }
      PUPable_decl(SINGLE_ARG(hasLockRemoteNode_31_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::modifyLockAll_32_closure : public SDAG::Closure {
            int impl_noname_32;
            int impl_noname_33;


      modifyLockAll_32_closure() {
        init();
      }
      modifyLockAll_32_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_32;}
            int & getP1() { return impl_noname_33;}
      void pup(PUP::er& __p) {
        __p | impl_noname_32;
        __p | impl_noname_33;
        packClosure(__p);
      }
      virtual ~modifyLockAll_32_closure() {
      }
      PUPable_decl(SINGLE_ARG(modifyLockAll_32_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::verifyLock_33_closure : public SDAG::Closure {
            int impl_noname_34;
            int impl_noname_35;
            int impl_noname_36;


      verifyLock_33_closure() {
        init();
      }
      verifyLock_33_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_34;}
            int & getP1() { return impl_noname_35;}
            int & getP2() { return impl_noname_36;}
      void pup(PUP::er& __p) {
        __p | impl_noname_34;
        __p | impl_noname_35;
        __p | impl_noname_36;
        packClosure(__p);
      }
      virtual ~verifyLock_33_closure() {
      }
      PUPable_decl(SINGLE_ARG(verifyLock_33_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::findghostsend_36_closure : public SDAG::Closure {
            int impl_noname_37;
            int impl_noname_38;


      findghostsend_36_closure() {
        init();
      }
      findghostsend_36_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_37;}
            int & getP1() { return impl_noname_38;}
      void pup(PUP::er& __p) {
        __p | impl_noname_37;
        __p | impl_noname_38;
        packClosure(__p);
      }
      virtual ~findghostsend_36_closure() {
      }
      PUPable_decl(SINGLE_ARG(findghostsend_36_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::shouldLoseGhost_37_closure : public SDAG::Closure {
            int impl_noname_39;
            int impl_noname_3a;
            int impl_noname_3b;


      shouldLoseGhost_37_closure() {
        init();
      }
      shouldLoseGhost_37_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_39;}
            int & getP1() { return impl_noname_3a;}
            int & getP2() { return impl_noname_3b;}
      void pup(PUP::er& __p) {
        __p | impl_noname_39;
        __p | impl_noname_3a;
        __p | impl_noname_3b;
        packClosure(__p);
      }
      virtual ~shouldLoseGhost_37_closure() {
      }
      PUPable_decl(SINGLE_ARG(shouldLoseGhost_37_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::addghostsendl_38_closure : public SDAG::Closure {
            int impl_noname_3c;
            int impl_noname_3d;
            int impl_noname_3e;
            int impl_noname_3f;


      addghostsendl_38_closure() {
        init();
      }
      addghostsendl_38_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_3c;}
            int & getP1() { return impl_noname_3d;}
            int & getP2() { return impl_noname_3e;}
            int & getP3() { return impl_noname_3f;}
      void pup(PUP::er& __p) {
        __p | impl_noname_3c;
        __p | impl_noname_3d;
        __p | impl_noname_3e;
        __p | impl_noname_3f;
        packClosure(__p);
      }
      virtual ~addghostsendl_38_closure() {
      }
      PUPable_decl(SINGLE_ARG(addghostsendl_38_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::addghostsendl1_39_closure : public SDAG::Closure {
            int impl_noname_40;
            int impl_noname_41;
            int impl_noname_42;


      addghostsendl1_39_closure() {
        init();
      }
      addghostsendl1_39_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_40;}
            int & getP1() { return impl_noname_41;}
            int & getP2() { return impl_noname_42;}
      void pup(PUP::er& __p) {
        __p | impl_noname_40;
        __p | impl_noname_41;
        __p | impl_noname_42;
        packClosure(__p);
      }
      virtual ~addghostsendl1_39_closure() {
      }
      PUPable_decl(SINGLE_ARG(addghostsendl1_39_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::addghostsendr_40_closure : public SDAG::Closure {
            int impl_noname_43;
            int impl_noname_44;
            int impl_noname_45;
            int impl_noname_46;


      addghostsendr_40_closure() {
        init();
      }
      addghostsendr_40_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_43;}
            int & getP1() { return impl_noname_44;}
            int & getP2() { return impl_noname_45;}
            int & getP3() { return impl_noname_46;}
      void pup(PUP::er& __p) {
        __p | impl_noname_43;
        __p | impl_noname_44;
        __p | impl_noname_45;
        __p | impl_noname_46;
        packClosure(__p);
      }
      virtual ~addghostsendr_40_closure() {
      }
      PUPable_decl(SINGLE_ARG(addghostsendr_40_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::addghostsendr1_41_closure : public SDAG::Closure {
            int impl_noname_47;
            int impl_noname_48;
            int impl_noname_49;


      addghostsendr1_41_closure() {
        init();
      }
      addghostsendr1_41_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_47;}
            int & getP1() { return impl_noname_48;}
            int & getP2() { return impl_noname_49;}
      void pup(PUP::er& __p) {
        __p | impl_noname_47;
        __p | impl_noname_48;
        __p | impl_noname_49;
        packClosure(__p);
      }
      virtual ~addghostsendr1_41_closure() {
      }
      PUPable_decl(SINGLE_ARG(addghostsendr1_41_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::willItLose_42_closure : public SDAG::Closure {
            int impl_noname_4a;
            int impl_noname_4b;


      willItLose_42_closure() {
        init();
      }
      willItLose_42_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_4a;}
            int & getP1() { return impl_noname_4b;}
      void pup(PUP::er& __p) {
        __p | impl_noname_4a;
        __p | impl_noname_4b;
        packClosure(__p);
      }
      virtual ~willItLose_42_closure() {
      }
      PUPable_decl(SINGLE_ARG(willItLose_42_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::interpolateElemCopy_43_closure : public SDAG::Closure {
            int impl_noname_4c;
            int impl_noname_4d;
            int impl_noname_4e;


      interpolateElemCopy_43_closure() {
        init();
      }
      interpolateElemCopy_43_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_4c;}
            int & getP1() { return impl_noname_4d;}
            int & getP2() { return impl_noname_4e;}
      void pup(PUP::er& __p) {
        __p | impl_noname_4c;
        __p | impl_noname_4d;
        __p | impl_noname_4e;
        packClosure(__p);
      }
      virtual ~interpolateElemCopy_43_closure() {
      }
      PUPable_decl(SINGLE_ARG(interpolateElemCopy_43_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::cleanupIDXL_44_closure : public SDAG::Closure {
            int impl_noname_4f;
            int impl_noname_50;


      cleanupIDXL_44_closure() {
        init();
      }
      cleanupIDXL_44_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_4f;}
            int & getP1() { return impl_noname_50;}
      void pup(PUP::er& __p) {
        __p | impl_noname_4f;
        __p | impl_noname_50;
        packClosure(__p);
      }
      virtual ~cleanupIDXL_44_closure() {
      }
      PUPable_decl(SINGLE_ARG(cleanupIDXL_44_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::purgeElement_45_closure : public SDAG::Closure {
            int impl_noname_51;
            int impl_noname_52;


      purgeElement_45_closure() {
        init();
      }
      purgeElement_45_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_51;}
            int & getP1() { return impl_noname_52;}
      void pup(PUP::er& __p) {
        __p | impl_noname_51;
        __p | impl_noname_52;
        packClosure(__p);
      }
      virtual ~purgeElement_45_closure() {
      }
      PUPable_decl(SINGLE_ARG(purgeElement_45_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::packEntData_46_closure : public SDAG::Closure {
            int impl_noname_53;
            int impl_noname_54;
            bool impl_noname_55;
            int impl_noname_56;


      packEntData_46_closure() {
        init();
      }
      packEntData_46_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_53;}
            int & getP1() { return impl_noname_54;}
            bool & getP2() { return impl_noname_55;}
            int & getP3() { return impl_noname_56;}
      void pup(PUP::er& __p) {
        __p | impl_noname_53;
        __p | impl_noname_54;
        __p | impl_noname_55;
        __p | impl_noname_56;
        packClosure(__p);
      }
      virtual ~packEntData_46_closure() {
      }
      PUPable_decl(SINGLE_ARG(packEntData_46_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::isFixedNodeRemote_47_closure : public SDAG::Closure {
            int impl_noname_57;
            int impl_noname_58;


      isFixedNodeRemote_47_closure() {
        init();
      }
      isFixedNodeRemote_47_closure(CkMigrateMessage*) {
        init();
      }
            int & getP0() { return impl_noname_57;}
            int & getP1() { return impl_noname_58;}
      void pup(PUP::er& __p) {
        __p | impl_noname_57;
        __p | impl_noname_58;
        packClosure(__p);
      }
      virtual ~isFixedNodeRemote_47_closure() {
      }
      PUPable_decl(SINGLE_ARG(isFixedNodeRemote_47_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_femMeshModify::finish_48_closure : public SDAG::Closure {
      

      finish_48_closure() {
        init();
      }
      finish_48_closure(CkMigrateMessage*) {
        init();
      }
            void pup(PUP::er& __p) {
        packClosure(__p);
      }
      virtual ~finish_48_closure() {
      }
      PUPable_decl(SINGLE_ARG(finish_48_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* DEFS: readonly CProxy_femMeshModify meshMod;
 */
extern CProxy_femMeshModify meshMod;
#ifndef CK_TEMPLATES_ONLY
extern "C" void __xlater_roPup_meshMod(void *_impl_pup_er) {
  PUP::er &_impl_p=*(PUP::er *)_impl_pup_er;
  _impl_p|meshMod;
}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message femMeshModMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_femMeshModMsg::operator new(size_t s){
  return femMeshModMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_femMeshModMsg::operator new(size_t s, int* sz){
  return femMeshModMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_femMeshModMsg::operator new(size_t s, int* sz,const int pb){
  return femMeshModMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_femMeshModMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return femMeshModMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_femMeshModMsg::operator new(size_t s, const int p) {
  return femMeshModMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_femMeshModMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return femMeshModMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_femMeshModMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_femMeshModMsg::CMessage_femMeshModMsg() {
femMeshModMsg *newmsg = (femMeshModMsg *)this;
}
void CMessage_femMeshModMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_femMeshModMsg::pack(femMeshModMsg *msg) {
  return (void *) msg;
}
femMeshModMsg* CMessage_femMeshModMsg::unpack(void* buf) {
  femMeshModMsg *msg = (femMeshModMsg *) buf;
  return msg;
}
int CMessage_femMeshModMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message FEMMeshMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_FEMMeshMsg::operator new(size_t s){
  return FEMMeshMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_FEMMeshMsg::operator new(size_t s, int* sz){
  return FEMMeshMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_FEMMeshMsg::operator new(size_t s, int* sz,const int pb){
  return FEMMeshMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_FEMMeshMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return FEMMeshMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_FEMMeshMsg::operator new(size_t s, const int p) {
  return FEMMeshMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_FEMMeshMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return FEMMeshMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_FEMMeshMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_FEMMeshMsg::CMessage_FEMMeshMsg() {
FEMMeshMsg *newmsg = (FEMMeshMsg *)this;
}
void CMessage_FEMMeshMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_FEMMeshMsg::pack(FEMMeshMsg *msg) {
  return (void *) msg;
}
FEMMeshMsg* CMessage_FEMMeshMsg::unpack(void* buf) {
  FEMMeshMsg *msg = (FEMMeshMsg *) buf;
  return msg;
}
int CMessage_FEMMeshMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message boolMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_boolMsg::operator new(size_t s){
  return boolMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_boolMsg::operator new(size_t s, int* sz){
  return boolMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_boolMsg::operator new(size_t s, int* sz,const int pb){
  return boolMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_boolMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return boolMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_boolMsg::operator new(size_t s, const int p) {
  return boolMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_boolMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return boolMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_boolMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_boolMsg::CMessage_boolMsg() {
boolMsg *newmsg = (boolMsg *)this;
}
void CMessage_boolMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_boolMsg::pack(boolMsg *msg) {
  return (void *) msg;
}
boolMsg* CMessage_boolMsg::unpack(void* buf) {
  boolMsg *msg = (boolMsg *) buf;
  return msg;
}
int CMessage_boolMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message intMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_intMsg::operator new(size_t s){
  return intMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_intMsg::operator new(size_t s, int* sz){
  return intMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_intMsg::operator new(size_t s, int* sz,const int pb){
  return intMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_intMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return intMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_intMsg::operator new(size_t s, const int p) {
  return intMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_intMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return intMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_intMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_intMsg::CMessage_intMsg() {
intMsg *newmsg = (intMsg *)this;
}
void CMessage_intMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_intMsg::pack(intMsg *msg) {
  return (void *) msg;
}
intMsg* CMessage_intMsg::unpack(void* buf) {
  intMsg *msg = (intMsg *) buf;
  return msg;
}
int CMessage_intMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message int2Msg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_int2Msg::operator new(size_t s){
  return int2Msg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_int2Msg::operator new(size_t s, int* sz){
  return int2Msg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_int2Msg::operator new(size_t s, int* sz,const int pb){
  return int2Msg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_int2Msg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return int2Msg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_int2Msg::operator new(size_t s, const int p) {
  return int2Msg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_int2Msg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return int2Msg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_int2Msg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_int2Msg::CMessage_int2Msg() {
int2Msg *newmsg = (int2Msg *)this;
}
void CMessage_int2Msg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_int2Msg::pack(int2Msg *msg) {
  return (void *) msg;
}
int2Msg* CMessage_int2Msg::unpack(void* buf) {
  int2Msg *msg = (int2Msg *) buf;
  return msg;
}
int CMessage_int2Msg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message double2Msg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_double2Msg::operator new(size_t s){
  return double2Msg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_double2Msg::operator new(size_t s, int* sz){
  return double2Msg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_double2Msg::operator new(size_t s, int* sz,const int pb){
  return double2Msg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_double2Msg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return double2Msg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_double2Msg::operator new(size_t s, const int p) {
  return double2Msg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_double2Msg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return double2Msg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_double2Msg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_double2Msg::CMessage_double2Msg() {
double2Msg *newmsg = (double2Msg *)this;
}
void CMessage_double2Msg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_double2Msg::pack(double2Msg *msg) {
  return (void *) msg;
}
double2Msg* CMessage_double2Msg::unpack(void* buf) {
  double2Msg *msg = (double2Msg *) buf;
  return msg;
}
int CMessage_double2Msg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message sharedNodeMsg{
int between[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_sharedNodeMsg::operator new(size_t s){
  return sharedNodeMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_sharedNodeMsg::operator new(size_t s, int* sz){
  return sharedNodeMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_sharedNodeMsg::operator new(size_t s, int* sz,const int pb){
  return sharedNodeMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_sharedNodeMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return sharedNodeMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_sharedNodeMsg::operator new(size_t s, int sz0) {
  int sizes[1];
  sizes[0] = sz0;
  return sharedNodeMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_sharedNodeMsg::operator new(size_t s, int sz0, const int p) {
  int sizes[1];
  sizes[0] = sz0;
  return sharedNodeMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_sharedNodeMsg::operator new(size_t s, int sz0, const int p, const GroupDepNum groupDepNum) {
  int sizes[1];
  sizes[0] = sz0;
  return sharedNodeMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_sharedNodeMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[1], pb, groupDepNum);
}
CMessage_sharedNodeMsg::CMessage_sharedNodeMsg() {
sharedNodeMsg *newmsg = (sharedNodeMsg *)this;
  newmsg->between = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
}
void CMessage_sharedNodeMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_sharedNodeMsg::pack(sharedNodeMsg *msg) {
  msg->between = (int *) ((char *)msg->between - (char *)msg);
  return (void *) msg;
}
sharedNodeMsg* CMessage_sharedNodeMsg::unpack(void* buf) {
  sharedNodeMsg *msg = (sharedNodeMsg *) buf;
  msg->between = (int *) ((size_t)msg->between + (char *)msg);
  return msg;
}
int CMessage_sharedNodeMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message removeSharedNodeMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_removeSharedNodeMsg::operator new(size_t s){
  return removeSharedNodeMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_removeSharedNodeMsg::operator new(size_t s, int* sz){
  return removeSharedNodeMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_removeSharedNodeMsg::operator new(size_t s, int* sz,const int pb){
  return removeSharedNodeMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_removeSharedNodeMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return removeSharedNodeMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_removeSharedNodeMsg::operator new(size_t s, const int p) {
  return removeSharedNodeMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_removeSharedNodeMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return removeSharedNodeMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_removeSharedNodeMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_removeSharedNodeMsg::CMessage_removeSharedNodeMsg() {
removeSharedNodeMsg *newmsg = (removeSharedNodeMsg *)this;
}
void CMessage_removeSharedNodeMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_removeSharedNodeMsg::pack(removeSharedNodeMsg *msg) {
  return (void *) msg;
}
removeSharedNodeMsg* CMessage_removeSharedNodeMsg::unpack(void* buf) {
  removeSharedNodeMsg *msg = (removeSharedNodeMsg *) buf;
  return msg;
}
int CMessage_removeSharedNodeMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message addNodeMsg{
int between[];
int chunks[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_addNodeMsg::operator new(size_t s){
  return addNodeMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_addNodeMsg::operator new(size_t s, int* sz){
  return addNodeMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_addNodeMsg::operator new(size_t s, int* sz,const int pb){
  return addNodeMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_addNodeMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return addNodeMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_addNodeMsg::operator new(size_t s, int sz0, int sz1) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addNodeMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_addNodeMsg::operator new(size_t s, int sz0, int sz1, const int p) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addNodeMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_addNodeMsg::operator new(size_t s, int sz0, int sz1, const int p, const GroupDepNum groupDepNum) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addNodeMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_addNodeMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  if(sizes==0)
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[1] + ALIGN_DEFAULT(sizeof(int)*sizes[1]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[2], pb, groupDepNum);
}
CMessage_addNodeMsg::CMessage_addNodeMsg() {
addNodeMsg *newmsg = (addNodeMsg *)this;
  newmsg->between = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
  newmsg->chunks = (int *) ((char *)newmsg + CkpvAccess(_offsets)[1]);
}
void CMessage_addNodeMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_addNodeMsg::pack(addNodeMsg *msg) {
  msg->between = (int *) ((char *)msg->between - (char *)msg);
  msg->chunks = (int *) ((char *)msg->chunks - (char *)msg);
  return (void *) msg;
}
addNodeMsg* CMessage_addNodeMsg::unpack(void* buf) {
  addNodeMsg *msg = (addNodeMsg *) buf;
  msg->between = (int *) ((size_t)msg->between + (char *)msg);
  msg->chunks = (int *) ((size_t)msg->chunks + (char *)msg);
  return msg;
}
int CMessage_addNodeMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message addGhostElemMsg{
int indices[];
int typeOfIndex[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_addGhostElemMsg::operator new(size_t s){
  return addGhostElemMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_addGhostElemMsg::operator new(size_t s, int* sz){
  return addGhostElemMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_addGhostElemMsg::operator new(size_t s, int* sz,const int pb){
  return addGhostElemMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_addGhostElemMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return addGhostElemMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_addGhostElemMsg::operator new(size_t s, int sz0, int sz1) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addGhostElemMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_addGhostElemMsg::operator new(size_t s, int sz0, int sz1, const int p) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addGhostElemMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_addGhostElemMsg::operator new(size_t s, int sz0, int sz1, const int p, const GroupDepNum groupDepNum) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addGhostElemMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_addGhostElemMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  if(sizes==0)
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[1] + ALIGN_DEFAULT(sizeof(int)*sizes[1]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[2], pb, groupDepNum);
}
CMessage_addGhostElemMsg::CMessage_addGhostElemMsg() {
addGhostElemMsg *newmsg = (addGhostElemMsg *)this;
  newmsg->indices = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
  newmsg->typeOfIndex = (int *) ((char *)newmsg + CkpvAccess(_offsets)[1]);
}
void CMessage_addGhostElemMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_addGhostElemMsg::pack(addGhostElemMsg *msg) {
  msg->indices = (int *) ((char *)msg->indices - (char *)msg);
  msg->typeOfIndex = (int *) ((char *)msg->typeOfIndex - (char *)msg);
  return (void *) msg;
}
addGhostElemMsg* CMessage_addGhostElemMsg::unpack(void* buf) {
  addGhostElemMsg *msg = (addGhostElemMsg *) buf;
  msg->indices = (int *) ((size_t)msg->indices + (char *)msg);
  msg->typeOfIndex = (int *) ((size_t)msg->typeOfIndex + (char *)msg);
  return msg;
}
int CMessage_addGhostElemMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message chunkListMsg{
int chunkList[];
int indexList[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_chunkListMsg::operator new(size_t s){
  return chunkListMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_chunkListMsg::operator new(size_t s, int* sz){
  return chunkListMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_chunkListMsg::operator new(size_t s, int* sz,const int pb){
  return chunkListMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_chunkListMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return chunkListMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_chunkListMsg::operator new(size_t s, int sz0, int sz1) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return chunkListMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_chunkListMsg::operator new(size_t s, int sz0, int sz1, const int p) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return chunkListMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_chunkListMsg::operator new(size_t s, int sz0, int sz1, const int p, const GroupDepNum groupDepNum) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return chunkListMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_chunkListMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  if(sizes==0)
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[1] + ALIGN_DEFAULT(sizeof(int)*sizes[1]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[2], pb, groupDepNum);
}
CMessage_chunkListMsg::CMessage_chunkListMsg() {
chunkListMsg *newmsg = (chunkListMsg *)this;
  newmsg->chunkList = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
  newmsg->indexList = (int *) ((char *)newmsg + CkpvAccess(_offsets)[1]);
}
void CMessage_chunkListMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_chunkListMsg::pack(chunkListMsg *msg) {
  msg->chunkList = (int *) ((char *)msg->chunkList - (char *)msg);
  msg->indexList = (int *) ((char *)msg->indexList - (char *)msg);
  return (void *) msg;
}
chunkListMsg* CMessage_chunkListMsg::unpack(void* buf) {
  chunkListMsg *msg = (chunkListMsg *) buf;
  msg->chunkList = (int *) ((size_t)msg->chunkList + (char *)msg);
  msg->indexList = (int *) ((size_t)msg->indexList + (char *)msg);
  return msg;
}
int CMessage_chunkListMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message addElemMsg{
int conn[];
int ghostIndices[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_addElemMsg::operator new(size_t s){
  return addElemMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_addElemMsg::operator new(size_t s, int* sz){
  return addElemMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_addElemMsg::operator new(size_t s, int* sz,const int pb){
  return addElemMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_addElemMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return addElemMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_addElemMsg::operator new(size_t s, int sz0, int sz1) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addElemMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_addElemMsg::operator new(size_t s, int sz0, int sz1, const int p) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addElemMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_addElemMsg::operator new(size_t s, int sz0, int sz1, const int p, const GroupDepNum groupDepNum) {
  int sizes[2];
  sizes[0] = sz0;
  sizes[1] = sz1;
  return addElemMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_addElemMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  if(sizes==0)
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[1] + ALIGN_DEFAULT(sizeof(int)*sizes[1]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[2], pb, groupDepNum);
}
CMessage_addElemMsg::CMessage_addElemMsg() {
addElemMsg *newmsg = (addElemMsg *)this;
  newmsg->conn = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
  newmsg->ghostIndices = (int *) ((char *)newmsg + CkpvAccess(_offsets)[1]);
}
void CMessage_addElemMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_addElemMsg::pack(addElemMsg *msg) {
  msg->conn = (int *) ((char *)msg->conn - (char *)msg);
  msg->ghostIndices = (int *) ((char *)msg->ghostIndices - (char *)msg);
  return (void *) msg;
}
addElemMsg* CMessage_addElemMsg::unpack(void* buf) {
  addElemMsg *msg = (addElemMsg *) buf;
  msg->conn = (int *) ((size_t)msg->conn + (char *)msg);
  msg->ghostIndices = (int *) ((size_t)msg->ghostIndices + (char *)msg);
  return msg;
}
int CMessage_addElemMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message removeGhostElemMsg{
int ghostIndices[];
int ghostRNIndices[];
int ghostREIndices[];
int sharedIndices[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_removeGhostElemMsg::operator new(size_t s){
  return removeGhostElemMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_removeGhostElemMsg::operator new(size_t s, int* sz){
  return removeGhostElemMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_removeGhostElemMsg::operator new(size_t s, int* sz,const int pb){
  return removeGhostElemMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_removeGhostElemMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return removeGhostElemMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_removeGhostElemMsg::operator new(size_t s, int sz0, int sz1, int sz2, int sz3) {
  int sizes[4];
  sizes[0] = sz0;
  sizes[1] = sz1;
  sizes[2] = sz2;
  sizes[3] = sz3;
  return removeGhostElemMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_removeGhostElemMsg::operator new(size_t s, int sz0, int sz1, int sz2, int sz3, const int p) {
  int sizes[4];
  sizes[0] = sz0;
  sizes[1] = sz1;
  sizes[2] = sz2;
  sizes[3] = sz3;
  return removeGhostElemMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_removeGhostElemMsg::operator new(size_t s, int sz0, int sz1, int sz2, int sz3, const int p, const GroupDepNum groupDepNum) {
  int sizes[4];
  sizes[0] = sz0;
  sizes[1] = sz1;
  sizes[2] = sz2;
  sizes[3] = sz3;
  return removeGhostElemMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_removeGhostElemMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  if(sizes==0)
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[2] = CkpvAccess(_offsets)[1] + ALIGN_DEFAULT(sizeof(int)*sizes[1]);
  if(sizes==0)
    CkpvAccess(_offsets)[3] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[3] = CkpvAccess(_offsets)[2] + ALIGN_DEFAULT(sizeof(int)*sizes[2]);
  if(sizes==0)
    CkpvAccess(_offsets)[4] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[4] = CkpvAccess(_offsets)[3] + ALIGN_DEFAULT(sizeof(int)*sizes[3]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[4], pb, groupDepNum);
}
CMessage_removeGhostElemMsg::CMessage_removeGhostElemMsg() {
removeGhostElemMsg *newmsg = (removeGhostElemMsg *)this;
  newmsg->ghostIndices = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
  newmsg->ghostRNIndices = (int *) ((char *)newmsg + CkpvAccess(_offsets)[1]);
  newmsg->ghostREIndices = (int *) ((char *)newmsg + CkpvAccess(_offsets)[2]);
  newmsg->sharedIndices = (int *) ((char *)newmsg + CkpvAccess(_offsets)[3]);
}
void CMessage_removeGhostElemMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_removeGhostElemMsg::pack(removeGhostElemMsg *msg) {
  msg->ghostIndices = (int *) ((char *)msg->ghostIndices - (char *)msg);
  msg->ghostRNIndices = (int *) ((char *)msg->ghostRNIndices - (char *)msg);
  msg->ghostREIndices = (int *) ((char *)msg->ghostREIndices - (char *)msg);
  msg->sharedIndices = (int *) ((char *)msg->sharedIndices - (char *)msg);
  return (void *) msg;
}
removeGhostElemMsg* CMessage_removeGhostElemMsg::unpack(void* buf) {
  removeGhostElemMsg *msg = (removeGhostElemMsg *) buf;
  msg->ghostIndices = (int *) ((size_t)msg->ghostIndices + (char *)msg);
  msg->ghostRNIndices = (int *) ((size_t)msg->ghostRNIndices + (char *)msg);
  msg->ghostREIndices = (int *) ((size_t)msg->ghostREIndices + (char *)msg);
  msg->sharedIndices = (int *) ((size_t)msg->sharedIndices + (char *)msg);
  return msg;
}
int CMessage_removeGhostElemMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message removeElemMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_removeElemMsg::operator new(size_t s){
  return removeElemMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_removeElemMsg::operator new(size_t s, int* sz){
  return removeElemMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_removeElemMsg::operator new(size_t s, int* sz,const int pb){
  return removeElemMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_removeElemMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return removeElemMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_removeElemMsg::operator new(size_t s, const int p) {
  return removeElemMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_removeElemMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return removeElemMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_removeElemMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_removeElemMsg::CMessage_removeElemMsg() {
removeElemMsg *newmsg = (removeElemMsg *)this;
}
void CMessage_removeElemMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_removeElemMsg::pack(removeElemMsg *msg) {
  return (void *) msg;
}
removeElemMsg* CMessage_removeElemMsg::unpack(void* buf) {
  removeElemMsg *msg = (removeElemMsg *) buf;
  return msg;
}
int CMessage_removeElemMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message verifyghostsendMsg{
int chunks[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_verifyghostsendMsg::operator new(size_t s){
  return verifyghostsendMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_verifyghostsendMsg::operator new(size_t s, int* sz){
  return verifyghostsendMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_verifyghostsendMsg::operator new(size_t s, int* sz,const int pb){
  return verifyghostsendMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_verifyghostsendMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return verifyghostsendMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_verifyghostsendMsg::operator new(size_t s, int sz0) {
  int sizes[1];
  sizes[0] = sz0;
  return verifyghostsendMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_verifyghostsendMsg::operator new(size_t s, int sz0, const int p) {
  int sizes[1];
  sizes[0] = sz0;
  return verifyghostsendMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_verifyghostsendMsg::operator new(size_t s, int sz0, const int p, const GroupDepNum groupDepNum) {
  int sizes[1];
  sizes[0] = sz0;
  return verifyghostsendMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_verifyghostsendMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[1], pb, groupDepNum);
}
CMessage_verifyghostsendMsg::CMessage_verifyghostsendMsg() {
verifyghostsendMsg *newmsg = (verifyghostsendMsg *)this;
  newmsg->chunks = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
}
void CMessage_verifyghostsendMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_verifyghostsendMsg::pack(verifyghostsendMsg *msg) {
  msg->chunks = (int *) ((char *)msg->chunks - (char *)msg);
  return (void *) msg;
}
verifyghostsendMsg* CMessage_verifyghostsendMsg::unpack(void* buf) {
  verifyghostsendMsg *msg = (verifyghostsendMsg *) buf;
  msg->chunks = (int *) ((size_t)msg->chunks + (char *)msg);
  return msg;
}
int CMessage_verifyghostsendMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message findgsMsg{
int chunks[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_findgsMsg::operator new(size_t s){
  return findgsMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_findgsMsg::operator new(size_t s, int* sz){
  return findgsMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_findgsMsg::operator new(size_t s, int* sz,const int pb){
  return findgsMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_findgsMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return findgsMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_findgsMsg::operator new(size_t s, int sz0) {
  int sizes[1];
  sizes[0] = sz0;
  return findgsMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_findgsMsg::operator new(size_t s, int sz0, const int p) {
  int sizes[1];
  sizes[0] = sz0;
  return findgsMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_findgsMsg::operator new(size_t s, int sz0, const int p, const GroupDepNum groupDepNum) {
  int sizes[1];
  sizes[0] = sz0;
  return findgsMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_findgsMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(int)*sizes[0]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[1], pb, groupDepNum);
}
CMessage_findgsMsg::CMessage_findgsMsg() {
findgsMsg *newmsg = (findgsMsg *)this;
  newmsg->chunks = (int *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
}
void CMessage_findgsMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_findgsMsg::pack(findgsMsg *msg) {
  msg->chunks = (int *) ((char *)msg->chunks - (char *)msg);
  return (void *) msg;
}
findgsMsg* CMessage_findgsMsg::unpack(void* buf) {
  findgsMsg *msg = (findgsMsg *) buf;
  msg->chunks = (int *) ((size_t)msg->chunks + (char *)msg);
  return msg;
}
int CMessage_findgsMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message entDataMsg{
char data[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_entDataMsg::operator new(size_t s){
  return entDataMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_entDataMsg::operator new(size_t s, int* sz){
  return entDataMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_entDataMsg::operator new(size_t s, int* sz,const int pb){
  return entDataMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_entDataMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return entDataMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_entDataMsg::operator new(size_t s, int sz0) {
  int sizes[1];
  sizes[0] = sz0;
  return entDataMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_entDataMsg::operator new(size_t s, int sz0, const int p) {
  int sizes[1];
  sizes[0] = sz0;
  return entDataMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_entDataMsg::operator new(size_t s, int sz0, const int p, const GroupDepNum groupDepNum) {
  int sizes[1];
  sizes[0] = sz0;
  return entDataMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_entDataMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(char)*sizes[0]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[1], pb, groupDepNum);
}
CMessage_entDataMsg::CMessage_entDataMsg() {
entDataMsg *newmsg = (entDataMsg *)this;
  newmsg->data = (char *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
}
void CMessage_entDataMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_entDataMsg::pack(entDataMsg *msg) {
  msg->data = (char *) ((char *)msg->data - (char *)msg);
  return (void *) msg;
}
entDataMsg* CMessage_entDataMsg::unpack(void* buf) {
  entDataMsg *msg = (entDataMsg *) buf;
  msg->data = (char *) ((size_t)msg->data + (char *)msg);
  return msg;
}
int CMessage_entDataMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message updateAttrsMsg{
char data[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_updateAttrsMsg::operator new(size_t s){
  return updateAttrsMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_updateAttrsMsg::operator new(size_t s, int* sz){
  return updateAttrsMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_updateAttrsMsg::operator new(size_t s, int* sz,const int pb){
  return updateAttrsMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_updateAttrsMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return updateAttrsMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_updateAttrsMsg::operator new(size_t s, int sz0) {
  int sizes[1];
  sizes[0] = sz0;
  return updateAttrsMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_updateAttrsMsg::operator new(size_t s, int sz0, const int p) {
  int sizes[1];
  sizes[0] = sz0;
  return updateAttrsMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_updateAttrsMsg::operator new(size_t s, int sz0, const int p, const GroupDepNum groupDepNum) {
  int sizes[1];
  sizes[0] = sz0;
  return updateAttrsMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_updateAttrsMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(char)*sizes[0]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[1], pb, groupDepNum);
}
CMessage_updateAttrsMsg::CMessage_updateAttrsMsg() {
updateAttrsMsg *newmsg = (updateAttrsMsg *)this;
  newmsg->data = (char *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
}
void CMessage_updateAttrsMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_updateAttrsMsg::pack(updateAttrsMsg *msg) {
  msg->data = (char *) ((char *)msg->data - (char *)msg);
  return (void *) msg;
}
updateAttrsMsg* CMessage_updateAttrsMsg::unpack(void* buf) {
  updateAttrsMsg *msg = (updateAttrsMsg *) buf;
  msg->data = (char *) ((size_t)msg->data + (char *)msg);
  return msg;
}
int CMessage_updateAttrsMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: array femMeshModify: ArrayElement{
femMeshModify(femMeshModMsg* impl_msg);
threaded sync void setFemMesh(FEMMeshMsg* impl_msg);
threaded sync intMsg* lockRemoteChunk(int2Msg* impl_msg);
threaded sync intMsg* unlockRemoteChunk(int2Msg* impl_msg);
threaded sync intMsg* lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3);
threaded sync intMsg* unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7);
threaded sync intMsg* addNodeRemote(addNodeMsg* impl_msg);
threaded sync void addSharedNodeRemote(sharedNodeMsg* impl_msg);
threaded sync void removeSharedNodeRemote(removeSharedNodeMsg* impl_msg);
threaded sync void addGhostElem(addGhostElemMsg* impl_msg);
threaded sync chunkListMsg* getChunksSharingGhostNode(int2Msg* impl_msg);
threaded sync intMsg* addElementRemote(addElemMsg* impl_msg);
threaded sync void removeGhostElem(removeGhostElemMsg* impl_msg);
threaded sync void removeElementRemote(removeElemMsg* impl_msg);
threaded sync void removeGhostNode(int fromChk, int sharedIdx);
threaded sync void refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e);
threaded sync void addToSharedList(int impl_noname_f, int impl_noname_10);
threaded sync void updateAttrs(updateAttrsMsg* impl_msg);
threaded sync double2Msg* getRemoteCoord(int impl_noname_11, int impl_noname_12);
threaded sync intMsg* getRemoteBound(int impl_noname_13, int impl_noname_14);
threaded sync intMsg* getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17);
threaded sync void updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a);
threaded sync void removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d);
threaded sync void addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20);
threaded sync void verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23);
threaded sync void idxllockRemote(int impl_noname_24, int impl_noname_25);
threaded sync void idxlunlockRemote(int impl_noname_26, int impl_noname_27);
threaded sync intMsg* eatIntoElement(int impl_noname_28, int impl_noname_29);
threaded sync intMsg* getLockOwner(int impl_noname_2a, int impl_noname_2b);
threaded sync boolMsg* knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e);
threaded sync intMsg* hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31);
threaded sync void modifyLockAll(int impl_noname_32, int impl_noname_33);
threaded sync boolMsg* verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36);
threaded sync void updateghostsend(verifyghostsendMsg* impl_msg);
threaded sync void verifyghostsend(verifyghostsendMsg* impl_msg);
threaded sync findgsMsg* findghostsend(int impl_noname_37, int impl_noname_38);
threaded sync boolMsg* shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b);
threaded sync void addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f);
threaded sync void addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42);
threaded sync void addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46);
threaded sync void addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49);
threaded sync boolMsg* willItLose(int impl_noname_4a, int impl_noname_4b);
threaded sync void interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e);
threaded sync void cleanupIDXL(int impl_noname_4f, int impl_noname_50);
threaded sync void purgeElement(int impl_noname_51, int impl_noname_52);
threaded sync entDataMsg* packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56);
threaded sync boolMsg* isFixedNodeRemote(int impl_noname_57, int impl_noname_58);
threaded sync void finish();
femMeshModify(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_femMeshModify::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_femMeshModify::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_femMeshModify::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_femMeshModify::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_femMeshModify::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_femMeshModify::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_femMeshModify::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: femMeshModify(femMeshModMsg* impl_msg);
 */
void CProxyElement_femMeshModify::insert(femMeshModMsg* impl_msg, int onPE)
{ 
    UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_femMeshModify::idx_femMeshModify_femMeshModMsg(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void setFemMesh(FEMMeshMsg* impl_msg);
 */
void CProxyElement_femMeshModify::setFemMesh(FEMMeshMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_setFemMesh_FEMMeshMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* lockRemoteChunk(int2Msg* impl_msg);
 */
intMsg* CProxyElement_femMeshModify::lockRemoteChunk(int2Msg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_lockRemoteChunk_int2Msg());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* unlockRemoteChunk(int2Msg* impl_msg);
 */
intMsg* CProxyElement_femMeshModify::unlockRemoteChunk(int2Msg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_unlockRemoteChunk_int2Msg());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3);
 */
intMsg* CProxyElement_femMeshModify::lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_0;
    implP|impl_noname_1;
    implP|impl_noname_2;
    implP|impl_noname_3;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_0;
    implP|impl_noname_1;
    implP|impl_noname_2;
    implP|impl_noname_3;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_lockRemoteNode_marshall5());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7);
 */
intMsg* CProxyElement_femMeshModify::unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_4;
    implP|impl_noname_5;
    implP|impl_noname_6;
    implP|impl_noname_7;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_4;
    implP|impl_noname_5;
    implP|impl_noname_6;
    implP|impl_noname_7;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_unlockRemoteNode_marshall6());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* addNodeRemote(addNodeMsg* impl_msg);
 */
intMsg* CProxyElement_femMeshModify::addNodeRemote(addNodeMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addNodeRemote_addNodeMsg());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addSharedNodeRemote(sharedNodeMsg* impl_msg);
 */
void CProxyElement_femMeshModify::addSharedNodeRemote(sharedNodeMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addSharedNodeRemote_sharedNodeMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeSharedNodeRemote(removeSharedNodeMsg* impl_msg);
 */
void CProxyElement_femMeshModify::removeSharedNodeRemote(removeSharedNodeMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_removeSharedNodeRemote_removeSharedNodeMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addGhostElem(addGhostElemMsg* impl_msg);
 */
void CProxyElement_femMeshModify::addGhostElem(addGhostElemMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addGhostElem_addGhostElemMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync chunkListMsg* getChunksSharingGhostNode(int2Msg* impl_msg);
 */
chunkListMsg* CProxyElement_femMeshModify::getChunksSharingGhostNode(int2Msg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  chunkListMsg* impl_msg_typed_ret = (chunkListMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_getChunksSharingGhostNode_int2Msg());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* addElementRemote(addElemMsg* impl_msg);
 */
intMsg* CProxyElement_femMeshModify::addElementRemote(addElemMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addElementRemote_addElemMsg());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeGhostElem(removeGhostElemMsg* impl_msg);
 */
void CProxyElement_femMeshModify::removeGhostElem(removeGhostElemMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_removeGhostElem_removeGhostElemMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeElementRemote(removeElemMsg* impl_msg);
 */
void CProxyElement_femMeshModify::removeElementRemote(removeElemMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_removeElementRemote_removeElemMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeGhostNode(int fromChk, int sharedIdx);
 */
void CProxyElement_femMeshModify::removeGhostNode(int fromChk, int sharedIdx, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int fromChk, int sharedIdx
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|fromChk;
    implP|sharedIdx;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|fromChk;
    implP|sharedIdx;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_removeGhostNode_marshall15());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e);
 */
void CProxyElement_femMeshModify::refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_8;
    implP|impl_noname_9;
    implP|impl_noname_a;
    implP|impl_noname_b;
    implP|impl_noname_c;
    implP|impl_noname_d;
    implP|impl_noname_e;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_8;
    implP|impl_noname_9;
    implP|impl_noname_a;
    implP|impl_noname_b;
    implP|impl_noname_c;
    implP|impl_noname_d;
    implP|impl_noname_e;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_refine_flip_element_leb_marshall16());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addToSharedList(int impl_noname_f, int impl_noname_10);
 */
void CProxyElement_femMeshModify::addToSharedList(int impl_noname_f, int impl_noname_10, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_f, int impl_noname_10
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_f;
    implP|impl_noname_10;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_f;
    implP|impl_noname_10;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addToSharedList_marshall17());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateAttrs(updateAttrsMsg* impl_msg);
 */
void CProxyElement_femMeshModify::updateAttrs(updateAttrsMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_updateAttrs_updateAttrsMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync double2Msg* getRemoteCoord(int impl_noname_11, int impl_noname_12);
 */
double2Msg* CProxyElement_femMeshModify::getRemoteCoord(int impl_noname_11, int impl_noname_12, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_11, int impl_noname_12
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_11;
    implP|impl_noname_12;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_11;
    implP|impl_noname_12;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  double2Msg* impl_msg_typed_ret = (double2Msg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_getRemoteCoord_marshall19());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getRemoteBound(int impl_noname_13, int impl_noname_14);
 */
intMsg* CProxyElement_femMeshModify::getRemoteBound(int impl_noname_13, int impl_noname_14, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_13, int impl_noname_14
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_13;
    implP|impl_noname_14;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_13;
    implP|impl_noname_14;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_getRemoteBound_marshall20());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17);
 */
intMsg* CProxyElement_femMeshModify::getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_15, int impl_noname_16, int impl_noname_17
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_15;
    implP|impl_noname_16;
    implP|impl_noname_17;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_15;
    implP|impl_noname_16;
    implP|impl_noname_17;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_getIdxGhostSend_marshall21());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a);
 */
void CProxyElement_femMeshModify::updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_18, int impl_noname_19, int impl_noname_1a
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_18;
    implP|impl_noname_19;
    implP|impl_noname_1a;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_18;
    implP|impl_noname_19;
    implP|impl_noname_1a;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_updateIdxlList_marshall22());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d);
 */
void CProxyElement_femMeshModify::removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_1b, int impl_noname_1c, int impl_noname_1d
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_1b;
    implP|impl_noname_1c;
    implP|impl_noname_1d;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_1b;
    implP|impl_noname_1c;
    implP|impl_noname_1d;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_removeIDXLRemote_marshall23());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20);
 */
void CProxyElement_femMeshModify::addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_1e, int impl_noname_1f, int impl_noname_20
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_1e;
    implP|impl_noname_1f;
    implP|impl_noname_20;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_1e;
    implP|impl_noname_1f;
    implP|impl_noname_20;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addTransIDXLRemote_marshall24());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23);
 */
void CProxyElement_femMeshModify::verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_21, int impl_noname_22, int impl_noname_23
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_21;
    implP|impl_noname_22;
    implP|impl_noname_23;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_21;
    implP|impl_noname_22;
    implP|impl_noname_23;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_verifyIdxlList_marshall25());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void idxllockRemote(int impl_noname_24, int impl_noname_25);
 */
void CProxyElement_femMeshModify::idxllockRemote(int impl_noname_24, int impl_noname_25, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_24, int impl_noname_25
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_24;
    implP|impl_noname_25;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_24;
    implP|impl_noname_25;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_idxllockRemote_marshall26());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void idxlunlockRemote(int impl_noname_26, int impl_noname_27);
 */
void CProxyElement_femMeshModify::idxlunlockRemote(int impl_noname_26, int impl_noname_27, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_26, int impl_noname_27
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_26;
    implP|impl_noname_27;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_26;
    implP|impl_noname_27;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_idxlunlockRemote_marshall27());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* eatIntoElement(int impl_noname_28, int impl_noname_29);
 */
intMsg* CProxyElement_femMeshModify::eatIntoElement(int impl_noname_28, int impl_noname_29, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_28, int impl_noname_29
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_28;
    implP|impl_noname_29;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_28;
    implP|impl_noname_29;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_eatIntoElement_marshall28());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getLockOwner(int impl_noname_2a, int impl_noname_2b);
 */
intMsg* CProxyElement_femMeshModify::getLockOwner(int impl_noname_2a, int impl_noname_2b, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_2a, int impl_noname_2b
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_2a;
    implP|impl_noname_2b;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_2a;
    implP|impl_noname_2b;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_getLockOwner_marshall29());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e);
 */
boolMsg* CProxyElement_femMeshModify::knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_2c, int impl_noname_2d, int impl_noname_2e
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_2c;
    implP|impl_noname_2d;
    implP|impl_noname_2e;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_2c;
    implP|impl_noname_2d;
    implP|impl_noname_2e;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  boolMsg* impl_msg_typed_ret = (boolMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_knowsAbtNode_marshall30());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31);
 */
intMsg* CProxyElement_femMeshModify::hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_2f, int impl_noname_30, int impl_noname_31
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_2f;
    implP|impl_noname_30;
    implP|impl_noname_31;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_2f;
    implP|impl_noname_30;
    implP|impl_noname_31;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  intMsg* impl_msg_typed_ret = (intMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_hasLockRemoteNode_marshall31());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void modifyLockAll(int impl_noname_32, int impl_noname_33);
 */
void CProxyElement_femMeshModify::modifyLockAll(int impl_noname_32, int impl_noname_33, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_32, int impl_noname_33
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_32;
    implP|impl_noname_33;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_32;
    implP|impl_noname_33;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_modifyLockAll_marshall32());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36);
 */
boolMsg* CProxyElement_femMeshModify::verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_34, int impl_noname_35, int impl_noname_36
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_34;
    implP|impl_noname_35;
    implP|impl_noname_36;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_34;
    implP|impl_noname_35;
    implP|impl_noname_36;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  boolMsg* impl_msg_typed_ret = (boolMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_verifyLock_marshall33());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateghostsend(verifyghostsendMsg* impl_msg);
 */
void CProxyElement_femMeshModify::updateghostsend(verifyghostsendMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_updateghostsend_verifyghostsendMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void verifyghostsend(verifyghostsendMsg* impl_msg);
 */
void CProxyElement_femMeshModify::verifyghostsend(verifyghostsendMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_verifyghostsend_verifyghostsendMsg());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync findgsMsg* findghostsend(int impl_noname_37, int impl_noname_38);
 */
findgsMsg* CProxyElement_femMeshModify::findghostsend(int impl_noname_37, int impl_noname_38, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_37, int impl_noname_38
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_37;
    implP|impl_noname_38;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_37;
    implP|impl_noname_38;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  findgsMsg* impl_msg_typed_ret = (findgsMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_findghostsend_marshall36());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b);
 */
boolMsg* CProxyElement_femMeshModify::shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_39, int impl_noname_3a, int impl_noname_3b
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_39;
    implP|impl_noname_3a;
    implP|impl_noname_3b;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_39;
    implP|impl_noname_3a;
    implP|impl_noname_3b;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  boolMsg* impl_msg_typed_ret = (boolMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_shouldLoseGhost_marshall37());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f);
 */
void CProxyElement_femMeshModify::addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_3c;
    implP|impl_noname_3d;
    implP|impl_noname_3e;
    implP|impl_noname_3f;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_3c;
    implP|impl_noname_3d;
    implP|impl_noname_3e;
    implP|impl_noname_3f;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addghostsendl_marshall38());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42);
 */
void CProxyElement_femMeshModify::addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_40, int impl_noname_41, int impl_noname_42
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_40;
    implP|impl_noname_41;
    implP|impl_noname_42;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_40;
    implP|impl_noname_41;
    implP|impl_noname_42;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addghostsendl1_marshall39());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46);
 */
void CProxyElement_femMeshModify::addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_43;
    implP|impl_noname_44;
    implP|impl_noname_45;
    implP|impl_noname_46;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_43;
    implP|impl_noname_44;
    implP|impl_noname_45;
    implP|impl_noname_46;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addghostsendr_marshall40());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49);
 */
void CProxyElement_femMeshModify::addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_47, int impl_noname_48, int impl_noname_49
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_47;
    implP|impl_noname_48;
    implP|impl_noname_49;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_47;
    implP|impl_noname_48;
    implP|impl_noname_49;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_addghostsendr1_marshall41());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* willItLose(int impl_noname_4a, int impl_noname_4b);
 */
boolMsg* CProxyElement_femMeshModify::willItLose(int impl_noname_4a, int impl_noname_4b, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_4a, int impl_noname_4b
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_4a;
    implP|impl_noname_4b;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_4a;
    implP|impl_noname_4b;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  boolMsg* impl_msg_typed_ret = (boolMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_willItLose_marshall42());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e);
 */
void CProxyElement_femMeshModify::interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_4c, int impl_noname_4d, int impl_noname_4e
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_4c;
    implP|impl_noname_4d;
    implP|impl_noname_4e;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_4c;
    implP|impl_noname_4d;
    implP|impl_noname_4e;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_interpolateElemCopy_marshall43());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void cleanupIDXL(int impl_noname_4f, int impl_noname_50);
 */
void CProxyElement_femMeshModify::cleanupIDXL(int impl_noname_4f, int impl_noname_50, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_4f, int impl_noname_50
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_4f;
    implP|impl_noname_50;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_4f;
    implP|impl_noname_50;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_cleanupIDXL_marshall44());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void purgeElement(int impl_noname_51, int impl_noname_52);
 */
void CProxyElement_femMeshModify::purgeElement(int impl_noname_51, int impl_noname_52, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_51, int impl_noname_52
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_51;
    implP|impl_noname_52;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_51;
    implP|impl_noname_52;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_purgeElement_marshall45());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync entDataMsg* packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56);
 */
entDataMsg* CProxyElement_femMeshModify::packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_53;
    implP|impl_noname_54;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)impl_noname_55;
    implP|impl_noname_56;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_53;
    implP|impl_noname_54;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<bool>::type>::type &)impl_noname_55;
    implP|impl_noname_56;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  entDataMsg* impl_msg_typed_ret = (entDataMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_packEntData_marshall46());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* isFixedNodeRemote(int impl_noname_57, int impl_noname_58);
 */
boolMsg* CProxyElement_femMeshModify::isFixedNodeRemote(int impl_noname_57, int impl_noname_58, const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  //Marshall: int impl_noname_57, int impl_noname_58
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|impl_noname_57;
    implP|impl_noname_58;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|impl_noname_57;
    implP|impl_noname_58;
  }
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  boolMsg* impl_msg_typed_ret = (boolMsg*)ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_isFixedNodeRemote_marshall47());
  return impl_msg_typed_ret;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void finish();
 */
void CProxyElement_femMeshModify::finish(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  void *impl_msg_typed_ret = ckSendSync(impl_amsg, CkIndex_femMeshModify::idx_finish_void());
  CkFreeSysMsg(impl_msg_typed_ret); 
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: femMeshModify(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: femMeshModify(femMeshModMsg* impl_msg);
 */
CkArrayID CProxy_femMeshModify::ckNew(femMeshModMsg* impl_msg, const CkArrayOptions &opts)
{
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_femMeshModify::idx_femMeshModify_femMeshModMsg(), opts);
  return gId;
}
void CProxy_femMeshModify::ckNew(femMeshModMsg* impl_msg, const CkArrayOptions &opts, CkCallback _ck_array_creation_cb)
{
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_femMeshModify::idx_femMeshModify_femMeshModMsg(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_femMeshModify::ckNew(femMeshModMsg* impl_msg, const int s1)
{
  CkArrayOptions opts(s1);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_femMeshModify::idx_femMeshModify_femMeshModMsg(), opts);
  return gId;
}
void CProxy_femMeshModify::ckNew(femMeshModMsg* impl_msg, const int s1, CkCallback _ck_array_creation_cb)
{
  CkArrayOptions opts(s1);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_femMeshModify::idx_femMeshModify_femMeshModMsg(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_femMeshModify::reg_femMeshModify_femMeshModMsg() {
  int epidx = CkRegisterEp("femMeshModify(femMeshModMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_femMeshModify_femMeshModMsg), CMessage_femMeshModMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)femMeshModMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_femMeshModify_femMeshModMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  new (impl_obj_void) femMeshModify((femMeshModMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void setFemMesh(FEMMeshMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_setFemMesh_FEMMeshMsg() {
  int epidx = CkRegisterEp("setFemMesh(FEMMeshMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_setFemMesh_FEMMeshMsg), CMessage_FEMMeshMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)FEMMeshMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_setFemMesh_FEMMeshMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_setFemMesh_FEMMeshMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_setFemMesh_FEMMeshMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->setFemMesh((FEMMeshMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* lockRemoteChunk(int2Msg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_lockRemoteChunk_int2Msg() {
  int epidx = CkRegisterEp("lockRemoteChunk(int2Msg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_lockRemoteChunk_int2Msg), CMessage_int2Msg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)int2Msg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_lockRemoteChunk_int2Msg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_lockRemoteChunk_int2Msg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_lockRemoteChunk_int2Msg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=(void *)   impl_obj->lockRemoteChunk((int2Msg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* unlockRemoteChunk(int2Msg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_unlockRemoteChunk_int2Msg() {
  int epidx = CkRegisterEp("unlockRemoteChunk(int2Msg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_unlockRemoteChunk_int2Msg), CMessage_int2Msg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)int2Msg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_unlockRemoteChunk_int2Msg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_unlockRemoteChunk_int2Msg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_unlockRemoteChunk_int2Msg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=(void *)   impl_obj->unlockRemoteChunk((int2Msg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_lockRemoteNode_marshall5() {
  int epidx = CkRegisterEp("lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3)",
      reinterpret_cast<CkCallFnPtr>(_call_lockRemoteNode_marshall5), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_lockRemoteNode_marshall5);

  return epidx;
}

void CkIndex_femMeshModify::_call_lockRemoteNode_marshall5(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_lockRemoteNode_marshall5, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_lockRemoteNode_marshall5(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_0;
  implP|impl_noname_0;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1;
  implP|impl_noname_1;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2;
  implP|impl_noname_2;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3;
  implP|impl_noname_3;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->lockRemoteNode(std::move(impl_noname_0.t), std::move(impl_noname_1.t), std::move(impl_noname_2.t), std::move(impl_noname_3.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_lockRemoteNode_marshall5(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_0;
  implP|impl_noname_0;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1;
  implP|impl_noname_1;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2;
  implP|impl_noname_2;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3;
  implP|impl_noname_3;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_0");
  implDestP|impl_noname_0;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_1");
  implDestP|impl_noname_1;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_2");
  implDestP|impl_noname_2;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_3");
  implDestP|impl_noname_3;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::lockRemoteNode_5_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_unlockRemoteNode_marshall6() {
  int epidx = CkRegisterEp("unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7)",
      reinterpret_cast<CkCallFnPtr>(_call_unlockRemoteNode_marshall6), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_unlockRemoteNode_marshall6);

  return epidx;
}

void CkIndex_femMeshModify::_call_unlockRemoteNode_marshall6(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_unlockRemoteNode_marshall6, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_unlockRemoteNode_marshall6(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4;
  implP|impl_noname_4;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_5;
  implP|impl_noname_5;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_6;
  implP|impl_noname_6;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_7;
  implP|impl_noname_7;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->unlockRemoteNode(std::move(impl_noname_4.t), std::move(impl_noname_5.t), std::move(impl_noname_6.t), std::move(impl_noname_7.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_unlockRemoteNode_marshall6(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4;
  implP|impl_noname_4;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_5;
  implP|impl_noname_5;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_6;
  implP|impl_noname_6;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_7;
  implP|impl_noname_7;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_4");
  implDestP|impl_noname_4;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_5");
  implDestP|impl_noname_5;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_6");
  implDestP|impl_noname_6;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_7");
  implDestP|impl_noname_7;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::unlockRemoteNode_6_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* addNodeRemote(addNodeMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addNodeRemote_addNodeMsg() {
  int epidx = CkRegisterEp("addNodeRemote(addNodeMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_addNodeRemote_addNodeMsg), CMessage_addNodeMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)addNodeMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_addNodeRemote_addNodeMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addNodeRemote_addNodeMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addNodeRemote_addNodeMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=(void *)   impl_obj->addNodeRemote((addNodeMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addSharedNodeRemote(sharedNodeMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addSharedNodeRemote_sharedNodeMsg() {
  int epidx = CkRegisterEp("addSharedNodeRemote(sharedNodeMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_addSharedNodeRemote_sharedNodeMsg), CMessage_sharedNodeMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)sharedNodeMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_addSharedNodeRemote_sharedNodeMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addSharedNodeRemote_sharedNodeMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addSharedNodeRemote_sharedNodeMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addSharedNodeRemote((sharedNodeMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeSharedNodeRemote(removeSharedNodeMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_removeSharedNodeRemote_removeSharedNodeMsg() {
  int epidx = CkRegisterEp("removeSharedNodeRemote(removeSharedNodeMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_removeSharedNodeRemote_removeSharedNodeMsg), CMessage_removeSharedNodeMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)removeSharedNodeMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_removeSharedNodeRemote_removeSharedNodeMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_removeSharedNodeRemote_removeSharedNodeMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_removeSharedNodeRemote_removeSharedNodeMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->removeSharedNodeRemote((removeSharedNodeMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addGhostElem(addGhostElemMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addGhostElem_addGhostElemMsg() {
  int epidx = CkRegisterEp("addGhostElem(addGhostElemMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_addGhostElem_addGhostElemMsg), CMessage_addGhostElemMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)addGhostElemMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_addGhostElem_addGhostElemMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addGhostElem_addGhostElemMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addGhostElem_addGhostElemMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addGhostElem((addGhostElemMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync chunkListMsg* getChunksSharingGhostNode(int2Msg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_getChunksSharingGhostNode_int2Msg() {
  int epidx = CkRegisterEp("getChunksSharingGhostNode(int2Msg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_getChunksSharingGhostNode_int2Msg), CMessage_int2Msg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)int2Msg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_getChunksSharingGhostNode_int2Msg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_getChunksSharingGhostNode_int2Msg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_getChunksSharingGhostNode_int2Msg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=(void *)   impl_obj->getChunksSharingGhostNode((int2Msg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* addElementRemote(addElemMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addElementRemote_addElemMsg() {
  int epidx = CkRegisterEp("addElementRemote(addElemMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_addElementRemote_addElemMsg), CMessage_addElemMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)addElemMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_addElementRemote_addElemMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addElementRemote_addElemMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addElementRemote_addElemMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=(void *)   impl_obj->addElementRemote((addElemMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeGhostElem(removeGhostElemMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_removeGhostElem_removeGhostElemMsg() {
  int epidx = CkRegisterEp("removeGhostElem(removeGhostElemMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_removeGhostElem_removeGhostElemMsg), CMessage_removeGhostElemMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)removeGhostElemMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_removeGhostElem_removeGhostElemMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_removeGhostElem_removeGhostElemMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_removeGhostElem_removeGhostElemMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->removeGhostElem((removeGhostElemMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeElementRemote(removeElemMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_removeElementRemote_removeElemMsg() {
  int epidx = CkRegisterEp("removeElementRemote(removeElemMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_removeElementRemote_removeElemMsg), CMessage_removeElemMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)removeElemMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_removeElementRemote_removeElemMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_removeElementRemote_removeElemMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_removeElementRemote_removeElemMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->removeElementRemote((removeElemMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeGhostNode(int fromChk, int sharedIdx);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_removeGhostNode_marshall15() {
  int epidx = CkRegisterEp("removeGhostNode(int fromChk, int sharedIdx)",
      reinterpret_cast<CkCallFnPtr>(_call_removeGhostNode_marshall15), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_removeGhostNode_marshall15);

  return epidx;
}

void CkIndex_femMeshModify::_call_removeGhostNode_marshall15(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_removeGhostNode_marshall15, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_removeGhostNode_marshall15(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int fromChk, int sharedIdx*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> fromChk;
  implP|fromChk;
  PUP::detail::TemporaryObjectHolder<int> sharedIdx;
  implP|sharedIdx;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->removeGhostNode(std::move(fromChk.t), std::move(sharedIdx.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_removeGhostNode_marshall15(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int fromChk, int sharedIdx*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> fromChk;
  implP|fromChk;
  PUP::detail::TemporaryObjectHolder<int> sharedIdx;
  implP|sharedIdx;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("fromChk");
  implDestP|fromChk;
  if (implDestP.hasComments()) implDestP.comment("sharedIdx");
  implDestP|sharedIdx;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::removeGhostNode_15_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_refine_flip_element_leb_marshall16() {
  int epidx = CkRegisterEp("refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e)",
      reinterpret_cast<CkCallFnPtr>(_call_refine_flip_element_leb_marshall16), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_refine_flip_element_leb_marshall16);

  return epidx;
}

void CkIndex_femMeshModify::_call_refine_flip_element_leb_marshall16(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_refine_flip_element_leb_marshall16, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_refine_flip_element_leb_marshall16(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_8;
  implP|impl_noname_8;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_9;
  implP|impl_noname_9;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_a;
  implP|impl_noname_a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_b;
  implP|impl_noname_b;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_c;
  implP|impl_noname_c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_d;
  implP|impl_noname_d;
  PUP::detail::TemporaryObjectHolder<double> impl_noname_e;
  implP|impl_noname_e;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->refine_flip_element_leb(std::move(impl_noname_8.t), std::move(impl_noname_9.t), std::move(impl_noname_a.t), std::move(impl_noname_b.t), std::move(impl_noname_c.t), std::move(impl_noname_d.t), std::move(impl_noname_e.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_refine_flip_element_leb_marshall16(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_8;
  implP|impl_noname_8;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_9;
  implP|impl_noname_9;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_a;
  implP|impl_noname_a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_b;
  implP|impl_noname_b;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_c;
  implP|impl_noname_c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_d;
  implP|impl_noname_d;
  PUP::detail::TemporaryObjectHolder<double> impl_noname_e;
  implP|impl_noname_e;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_8");
  implDestP|impl_noname_8;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_9");
  implDestP|impl_noname_9;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_a");
  implDestP|impl_noname_a;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_b");
  implDestP|impl_noname_b;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_c");
  implDestP|impl_noname_c;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_d");
  implDestP|impl_noname_d;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_e");
  implDestP|impl_noname_e;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::refine_flip_element_leb_16_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addToSharedList(int impl_noname_f, int impl_noname_10);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addToSharedList_marshall17() {
  int epidx = CkRegisterEp("addToSharedList(int impl_noname_f, int impl_noname_10)",
      reinterpret_cast<CkCallFnPtr>(_call_addToSharedList_marshall17), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_addToSharedList_marshall17);

  return epidx;
}

void CkIndex_femMeshModify::_call_addToSharedList_marshall17(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addToSharedList_marshall17, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addToSharedList_marshall17(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_f, int impl_noname_10*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_f;
  implP|impl_noname_f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_10;
  implP|impl_noname_10;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addToSharedList(std::move(impl_noname_f.t), std::move(impl_noname_10.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_addToSharedList_marshall17(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_f, int impl_noname_10*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_f;
  implP|impl_noname_f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_10;
  implP|impl_noname_10;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_f");
  implDestP|impl_noname_f;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_10");
  implDestP|impl_noname_10;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::addToSharedList_17_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateAttrs(updateAttrsMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_updateAttrs_updateAttrsMsg() {
  int epidx = CkRegisterEp("updateAttrs(updateAttrsMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_updateAttrs_updateAttrsMsg), CMessage_updateAttrsMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)updateAttrsMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_updateAttrs_updateAttrsMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_updateAttrs_updateAttrsMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_updateAttrs_updateAttrsMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->updateAttrs((updateAttrsMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync double2Msg* getRemoteCoord(int impl_noname_11, int impl_noname_12);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_getRemoteCoord_marshall19() {
  int epidx = CkRegisterEp("getRemoteCoord(int impl_noname_11, int impl_noname_12)",
      reinterpret_cast<CkCallFnPtr>(_call_getRemoteCoord_marshall19), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getRemoteCoord_marshall19);

  return epidx;
}

void CkIndex_femMeshModify::_call_getRemoteCoord_marshall19(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_getRemoteCoord_marshall19, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_getRemoteCoord_marshall19(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_11, int impl_noname_12*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_11;
  implP|impl_noname_11;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_12;
  implP|impl_noname_12;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->getRemoteCoord(std::move(impl_noname_11.t), std::move(impl_noname_12.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_getRemoteCoord_marshall19(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_11, int impl_noname_12*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_11;
  implP|impl_noname_11;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_12;
  implP|impl_noname_12;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_11");
  implDestP|impl_noname_11;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_12");
  implDestP|impl_noname_12;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::getRemoteCoord_19_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getRemoteBound(int impl_noname_13, int impl_noname_14);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_getRemoteBound_marshall20() {
  int epidx = CkRegisterEp("getRemoteBound(int impl_noname_13, int impl_noname_14)",
      reinterpret_cast<CkCallFnPtr>(_call_getRemoteBound_marshall20), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getRemoteBound_marshall20);

  return epidx;
}

void CkIndex_femMeshModify::_call_getRemoteBound_marshall20(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_getRemoteBound_marshall20, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_getRemoteBound_marshall20(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_13, int impl_noname_14*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_13;
  implP|impl_noname_13;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_14;
  implP|impl_noname_14;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->getRemoteBound(std::move(impl_noname_13.t), std::move(impl_noname_14.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_getRemoteBound_marshall20(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_13, int impl_noname_14*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_13;
  implP|impl_noname_13;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_14;
  implP|impl_noname_14;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_13");
  implDestP|impl_noname_13;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_14");
  implDestP|impl_noname_14;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::getRemoteBound_20_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_getIdxGhostSend_marshall21() {
  int epidx = CkRegisterEp("getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17)",
      reinterpret_cast<CkCallFnPtr>(_call_getIdxGhostSend_marshall21), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getIdxGhostSend_marshall21);

  return epidx;
}

void CkIndex_femMeshModify::_call_getIdxGhostSend_marshall21(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_getIdxGhostSend_marshall21, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_getIdxGhostSend_marshall21(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_15, int impl_noname_16, int impl_noname_17*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_15;
  implP|impl_noname_15;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_16;
  implP|impl_noname_16;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_17;
  implP|impl_noname_17;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->getIdxGhostSend(std::move(impl_noname_15.t), std::move(impl_noname_16.t), std::move(impl_noname_17.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_getIdxGhostSend_marshall21(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_15, int impl_noname_16, int impl_noname_17*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_15;
  implP|impl_noname_15;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_16;
  implP|impl_noname_16;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_17;
  implP|impl_noname_17;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_15");
  implDestP|impl_noname_15;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_16");
  implDestP|impl_noname_16;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_17");
  implDestP|impl_noname_17;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::getIdxGhostSend_21_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_updateIdxlList_marshall22() {
  int epidx = CkRegisterEp("updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a)",
      reinterpret_cast<CkCallFnPtr>(_call_updateIdxlList_marshall22), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_updateIdxlList_marshall22);

  return epidx;
}

void CkIndex_femMeshModify::_call_updateIdxlList_marshall22(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_updateIdxlList_marshall22, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_updateIdxlList_marshall22(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_18, int impl_noname_19, int impl_noname_1a*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_18;
  implP|impl_noname_18;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_19;
  implP|impl_noname_19;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1a;
  implP|impl_noname_1a;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->updateIdxlList(std::move(impl_noname_18.t), std::move(impl_noname_19.t), std::move(impl_noname_1a.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_updateIdxlList_marshall22(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_18, int impl_noname_19, int impl_noname_1a*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_18;
  implP|impl_noname_18;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_19;
  implP|impl_noname_19;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1a;
  implP|impl_noname_1a;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_18");
  implDestP|impl_noname_18;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_19");
  implDestP|impl_noname_19;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_1a");
  implDestP|impl_noname_1a;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::updateIdxlList_22_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_removeIDXLRemote_marshall23() {
  int epidx = CkRegisterEp("removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d)",
      reinterpret_cast<CkCallFnPtr>(_call_removeIDXLRemote_marshall23), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_removeIDXLRemote_marshall23);

  return epidx;
}

void CkIndex_femMeshModify::_call_removeIDXLRemote_marshall23(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_removeIDXLRemote_marshall23, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_removeIDXLRemote_marshall23(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_1b, int impl_noname_1c, int impl_noname_1d*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1b;
  implP|impl_noname_1b;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1c;
  implP|impl_noname_1c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1d;
  implP|impl_noname_1d;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->removeIDXLRemote(std::move(impl_noname_1b.t), std::move(impl_noname_1c.t), std::move(impl_noname_1d.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_removeIDXLRemote_marshall23(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_1b, int impl_noname_1c, int impl_noname_1d*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1b;
  implP|impl_noname_1b;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1c;
  implP|impl_noname_1c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1d;
  implP|impl_noname_1d;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_1b");
  implDestP|impl_noname_1b;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_1c");
  implDestP|impl_noname_1c;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_1d");
  implDestP|impl_noname_1d;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::removeIDXLRemote_23_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addTransIDXLRemote_marshall24() {
  int epidx = CkRegisterEp("addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20)",
      reinterpret_cast<CkCallFnPtr>(_call_addTransIDXLRemote_marshall24), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_addTransIDXLRemote_marshall24);

  return epidx;
}

void CkIndex_femMeshModify::_call_addTransIDXLRemote_marshall24(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addTransIDXLRemote_marshall24, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addTransIDXLRemote_marshall24(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_1e, int impl_noname_1f, int impl_noname_20*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1e;
  implP|impl_noname_1e;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1f;
  implP|impl_noname_1f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_20;
  implP|impl_noname_20;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addTransIDXLRemote(std::move(impl_noname_1e.t), std::move(impl_noname_1f.t), std::move(impl_noname_20.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_addTransIDXLRemote_marshall24(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_1e, int impl_noname_1f, int impl_noname_20*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1e;
  implP|impl_noname_1e;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_1f;
  implP|impl_noname_1f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_20;
  implP|impl_noname_20;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_1e");
  implDestP|impl_noname_1e;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_1f");
  implDestP|impl_noname_1f;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_20");
  implDestP|impl_noname_20;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::addTransIDXLRemote_24_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_verifyIdxlList_marshall25() {
  int epidx = CkRegisterEp("verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23)",
      reinterpret_cast<CkCallFnPtr>(_call_verifyIdxlList_marshall25), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_verifyIdxlList_marshall25);

  return epidx;
}

void CkIndex_femMeshModify::_call_verifyIdxlList_marshall25(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_verifyIdxlList_marshall25, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_verifyIdxlList_marshall25(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_21, int impl_noname_22, int impl_noname_23*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_21;
  implP|impl_noname_21;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_22;
  implP|impl_noname_22;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_23;
  implP|impl_noname_23;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->verifyIdxlList(std::move(impl_noname_21.t), std::move(impl_noname_22.t), std::move(impl_noname_23.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_verifyIdxlList_marshall25(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_21, int impl_noname_22, int impl_noname_23*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_21;
  implP|impl_noname_21;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_22;
  implP|impl_noname_22;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_23;
  implP|impl_noname_23;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_21");
  implDestP|impl_noname_21;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_22");
  implDestP|impl_noname_22;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_23");
  implDestP|impl_noname_23;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::verifyIdxlList_25_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void idxllockRemote(int impl_noname_24, int impl_noname_25);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_idxllockRemote_marshall26() {
  int epidx = CkRegisterEp("idxllockRemote(int impl_noname_24, int impl_noname_25)",
      reinterpret_cast<CkCallFnPtr>(_call_idxllockRemote_marshall26), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_idxllockRemote_marshall26);

  return epidx;
}

void CkIndex_femMeshModify::_call_idxllockRemote_marshall26(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_idxllockRemote_marshall26, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_idxllockRemote_marshall26(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_24, int impl_noname_25*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_24;
  implP|impl_noname_24;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_25;
  implP|impl_noname_25;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->idxllockRemote(std::move(impl_noname_24.t), std::move(impl_noname_25.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_idxllockRemote_marshall26(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_24, int impl_noname_25*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_24;
  implP|impl_noname_24;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_25;
  implP|impl_noname_25;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_24");
  implDestP|impl_noname_24;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_25");
  implDestP|impl_noname_25;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::idxllockRemote_26_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void idxlunlockRemote(int impl_noname_26, int impl_noname_27);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_idxlunlockRemote_marshall27() {
  int epidx = CkRegisterEp("idxlunlockRemote(int impl_noname_26, int impl_noname_27)",
      reinterpret_cast<CkCallFnPtr>(_call_idxlunlockRemote_marshall27), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_idxlunlockRemote_marshall27);

  return epidx;
}

void CkIndex_femMeshModify::_call_idxlunlockRemote_marshall27(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_idxlunlockRemote_marshall27, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_idxlunlockRemote_marshall27(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_26, int impl_noname_27*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_26;
  implP|impl_noname_26;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_27;
  implP|impl_noname_27;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->idxlunlockRemote(std::move(impl_noname_26.t), std::move(impl_noname_27.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_idxlunlockRemote_marshall27(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_26, int impl_noname_27*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_26;
  implP|impl_noname_26;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_27;
  implP|impl_noname_27;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_26");
  implDestP|impl_noname_26;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_27");
  implDestP|impl_noname_27;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::idxlunlockRemote_27_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* eatIntoElement(int impl_noname_28, int impl_noname_29);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_eatIntoElement_marshall28() {
  int epidx = CkRegisterEp("eatIntoElement(int impl_noname_28, int impl_noname_29)",
      reinterpret_cast<CkCallFnPtr>(_call_eatIntoElement_marshall28), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_eatIntoElement_marshall28);

  return epidx;
}

void CkIndex_femMeshModify::_call_eatIntoElement_marshall28(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_eatIntoElement_marshall28, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_eatIntoElement_marshall28(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_28, int impl_noname_29*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_28;
  implP|impl_noname_28;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_29;
  implP|impl_noname_29;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->eatIntoElement(std::move(impl_noname_28.t), std::move(impl_noname_29.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_eatIntoElement_marshall28(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_28, int impl_noname_29*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_28;
  implP|impl_noname_28;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_29;
  implP|impl_noname_29;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_28");
  implDestP|impl_noname_28;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_29");
  implDestP|impl_noname_29;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::eatIntoElement_28_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getLockOwner(int impl_noname_2a, int impl_noname_2b);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_getLockOwner_marshall29() {
  int epidx = CkRegisterEp("getLockOwner(int impl_noname_2a, int impl_noname_2b)",
      reinterpret_cast<CkCallFnPtr>(_call_getLockOwner_marshall29), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_getLockOwner_marshall29);

  return epidx;
}

void CkIndex_femMeshModify::_call_getLockOwner_marshall29(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_getLockOwner_marshall29, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_getLockOwner_marshall29(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_2a, int impl_noname_2b*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2a;
  implP|impl_noname_2a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2b;
  implP|impl_noname_2b;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->getLockOwner(std::move(impl_noname_2a.t), std::move(impl_noname_2b.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_getLockOwner_marshall29(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_2a, int impl_noname_2b*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2a;
  implP|impl_noname_2a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2b;
  implP|impl_noname_2b;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_2a");
  implDestP|impl_noname_2a;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_2b");
  implDestP|impl_noname_2b;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::getLockOwner_29_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_knowsAbtNode_marshall30() {
  int epidx = CkRegisterEp("knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e)",
      reinterpret_cast<CkCallFnPtr>(_call_knowsAbtNode_marshall30), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_knowsAbtNode_marshall30);

  return epidx;
}

void CkIndex_femMeshModify::_call_knowsAbtNode_marshall30(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_knowsAbtNode_marshall30, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_knowsAbtNode_marshall30(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_2c, int impl_noname_2d, int impl_noname_2e*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2c;
  implP|impl_noname_2c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2d;
  implP|impl_noname_2d;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2e;
  implP|impl_noname_2e;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->knowsAbtNode(std::move(impl_noname_2c.t), std::move(impl_noname_2d.t), std::move(impl_noname_2e.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_knowsAbtNode_marshall30(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_2c, int impl_noname_2d, int impl_noname_2e*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2c;
  implP|impl_noname_2c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2d;
  implP|impl_noname_2d;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2e;
  implP|impl_noname_2e;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_2c");
  implDestP|impl_noname_2c;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_2d");
  implDestP|impl_noname_2d;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_2e");
  implDestP|impl_noname_2e;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::knowsAbtNode_30_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_hasLockRemoteNode_marshall31() {
  int epidx = CkRegisterEp("hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31)",
      reinterpret_cast<CkCallFnPtr>(_call_hasLockRemoteNode_marshall31), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_hasLockRemoteNode_marshall31);

  return epidx;
}

void CkIndex_femMeshModify::_call_hasLockRemoteNode_marshall31(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_hasLockRemoteNode_marshall31, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_hasLockRemoteNode_marshall31(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_2f, int impl_noname_30, int impl_noname_31*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2f;
  implP|impl_noname_2f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_30;
  implP|impl_noname_30;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_31;
  implP|impl_noname_31;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->hasLockRemoteNode(std::move(impl_noname_2f.t), std::move(impl_noname_30.t), std::move(impl_noname_31.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_hasLockRemoteNode_marshall31(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_2f, int impl_noname_30, int impl_noname_31*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_2f;
  implP|impl_noname_2f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_30;
  implP|impl_noname_30;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_31;
  implP|impl_noname_31;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_2f");
  implDestP|impl_noname_2f;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_30");
  implDestP|impl_noname_30;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_31");
  implDestP|impl_noname_31;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::hasLockRemoteNode_31_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void modifyLockAll(int impl_noname_32, int impl_noname_33);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_modifyLockAll_marshall32() {
  int epidx = CkRegisterEp("modifyLockAll(int impl_noname_32, int impl_noname_33)",
      reinterpret_cast<CkCallFnPtr>(_call_modifyLockAll_marshall32), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_modifyLockAll_marshall32);

  return epidx;
}

void CkIndex_femMeshModify::_call_modifyLockAll_marshall32(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_modifyLockAll_marshall32, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_modifyLockAll_marshall32(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_32, int impl_noname_33*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_32;
  implP|impl_noname_32;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_33;
  implP|impl_noname_33;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->modifyLockAll(std::move(impl_noname_32.t), std::move(impl_noname_33.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_modifyLockAll_marshall32(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_32, int impl_noname_33*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_32;
  implP|impl_noname_32;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_33;
  implP|impl_noname_33;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_32");
  implDestP|impl_noname_32;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_33");
  implDestP|impl_noname_33;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::modifyLockAll_32_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_verifyLock_marshall33() {
  int epidx = CkRegisterEp("verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36)",
      reinterpret_cast<CkCallFnPtr>(_call_verifyLock_marshall33), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_verifyLock_marshall33);

  return epidx;
}

void CkIndex_femMeshModify::_call_verifyLock_marshall33(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_verifyLock_marshall33, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_verifyLock_marshall33(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_34, int impl_noname_35, int impl_noname_36*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_34;
  implP|impl_noname_34;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_35;
  implP|impl_noname_35;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_36;
  implP|impl_noname_36;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->verifyLock(std::move(impl_noname_34.t), std::move(impl_noname_35.t), std::move(impl_noname_36.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_verifyLock_marshall33(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_34, int impl_noname_35, int impl_noname_36*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_34;
  implP|impl_noname_34;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_35;
  implP|impl_noname_35;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_36;
  implP|impl_noname_36;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_34");
  implDestP|impl_noname_34;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_35");
  implDestP|impl_noname_35;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_36");
  implDestP|impl_noname_36;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::verifyLock_33_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateghostsend(verifyghostsendMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_updateghostsend_verifyghostsendMsg() {
  int epidx = CkRegisterEp("updateghostsend(verifyghostsendMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_updateghostsend_verifyghostsendMsg), CMessage_verifyghostsendMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)verifyghostsendMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_updateghostsend_verifyghostsendMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_updateghostsend_verifyghostsendMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_updateghostsend_verifyghostsendMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->updateghostsend((verifyghostsendMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void verifyghostsend(verifyghostsendMsg* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_verifyghostsend_verifyghostsendMsg() {
  int epidx = CkRegisterEp("verifyghostsend(verifyghostsendMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_verifyghostsend_verifyghostsendMsg), CMessage_verifyghostsendMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)verifyghostsendMsg::ckDebugPup);
  return epidx;
}

void CkIndex_femMeshModify::_call_verifyghostsend_verifyghostsendMsg(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_verifyghostsend_verifyghostsendMsg, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_verifyghostsend_verifyghostsendMsg(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->verifyghostsend((verifyghostsendMsg*)impl_msg);
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync findgsMsg* findghostsend(int impl_noname_37, int impl_noname_38);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_findghostsend_marshall36() {
  int epidx = CkRegisterEp("findghostsend(int impl_noname_37, int impl_noname_38)",
      reinterpret_cast<CkCallFnPtr>(_call_findghostsend_marshall36), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_findghostsend_marshall36);

  return epidx;
}

void CkIndex_femMeshModify::_call_findghostsend_marshall36(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_findghostsend_marshall36, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_findghostsend_marshall36(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_37, int impl_noname_38*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_37;
  implP|impl_noname_37;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_38;
  implP|impl_noname_38;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->findghostsend(std::move(impl_noname_37.t), std::move(impl_noname_38.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_findghostsend_marshall36(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_37, int impl_noname_38*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_37;
  implP|impl_noname_37;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_38;
  implP|impl_noname_38;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_37");
  implDestP|impl_noname_37;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_38");
  implDestP|impl_noname_38;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::findghostsend_36_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_shouldLoseGhost_marshall37() {
  int epidx = CkRegisterEp("shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b)",
      reinterpret_cast<CkCallFnPtr>(_call_shouldLoseGhost_marshall37), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_shouldLoseGhost_marshall37);

  return epidx;
}

void CkIndex_femMeshModify::_call_shouldLoseGhost_marshall37(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_shouldLoseGhost_marshall37, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_shouldLoseGhost_marshall37(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_39, int impl_noname_3a, int impl_noname_3b*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_39;
  implP|impl_noname_39;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3a;
  implP|impl_noname_3a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3b;
  implP|impl_noname_3b;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->shouldLoseGhost(std::move(impl_noname_39.t), std::move(impl_noname_3a.t), std::move(impl_noname_3b.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_shouldLoseGhost_marshall37(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_39, int impl_noname_3a, int impl_noname_3b*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_39;
  implP|impl_noname_39;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3a;
  implP|impl_noname_3a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3b;
  implP|impl_noname_3b;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_39");
  implDestP|impl_noname_39;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_3a");
  implDestP|impl_noname_3a;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_3b");
  implDestP|impl_noname_3b;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::shouldLoseGhost_37_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addghostsendl_marshall38() {
  int epidx = CkRegisterEp("addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f)",
      reinterpret_cast<CkCallFnPtr>(_call_addghostsendl_marshall38), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_addghostsendl_marshall38);

  return epidx;
}

void CkIndex_femMeshModify::_call_addghostsendl_marshall38(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addghostsendl_marshall38, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addghostsendl_marshall38(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3c;
  implP|impl_noname_3c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3d;
  implP|impl_noname_3d;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3e;
  implP|impl_noname_3e;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3f;
  implP|impl_noname_3f;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addghostsendl(std::move(impl_noname_3c.t), std::move(impl_noname_3d.t), std::move(impl_noname_3e.t), std::move(impl_noname_3f.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_addghostsendl_marshall38(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3c;
  implP|impl_noname_3c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3d;
  implP|impl_noname_3d;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3e;
  implP|impl_noname_3e;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_3f;
  implP|impl_noname_3f;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_3c");
  implDestP|impl_noname_3c;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_3d");
  implDestP|impl_noname_3d;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_3e");
  implDestP|impl_noname_3e;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_3f");
  implDestP|impl_noname_3f;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::addghostsendl_38_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addghostsendl1_marshall39() {
  int epidx = CkRegisterEp("addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42)",
      reinterpret_cast<CkCallFnPtr>(_call_addghostsendl1_marshall39), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_addghostsendl1_marshall39);

  return epidx;
}

void CkIndex_femMeshModify::_call_addghostsendl1_marshall39(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addghostsendl1_marshall39, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addghostsendl1_marshall39(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_40, int impl_noname_41, int impl_noname_42*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_40;
  implP|impl_noname_40;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_41;
  implP|impl_noname_41;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_42;
  implP|impl_noname_42;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addghostsendl1(std::move(impl_noname_40.t), std::move(impl_noname_41.t), std::move(impl_noname_42.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_addghostsendl1_marshall39(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_40, int impl_noname_41, int impl_noname_42*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_40;
  implP|impl_noname_40;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_41;
  implP|impl_noname_41;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_42;
  implP|impl_noname_42;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_40");
  implDestP|impl_noname_40;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_41");
  implDestP|impl_noname_41;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_42");
  implDestP|impl_noname_42;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::addghostsendl1_39_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addghostsendr_marshall40() {
  int epidx = CkRegisterEp("addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46)",
      reinterpret_cast<CkCallFnPtr>(_call_addghostsendr_marshall40), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_addghostsendr_marshall40);

  return epidx;
}

void CkIndex_femMeshModify::_call_addghostsendr_marshall40(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addghostsendr_marshall40, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addghostsendr_marshall40(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_43;
  implP|impl_noname_43;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_44;
  implP|impl_noname_44;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_45;
  implP|impl_noname_45;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_46;
  implP|impl_noname_46;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addghostsendr(std::move(impl_noname_43.t), std::move(impl_noname_44.t), std::move(impl_noname_45.t), std::move(impl_noname_46.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_addghostsendr_marshall40(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_43;
  implP|impl_noname_43;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_44;
  implP|impl_noname_44;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_45;
  implP|impl_noname_45;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_46;
  implP|impl_noname_46;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_43");
  implDestP|impl_noname_43;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_44");
  implDestP|impl_noname_44;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_45");
  implDestP|impl_noname_45;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_46");
  implDestP|impl_noname_46;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::addghostsendr_40_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_addghostsendr1_marshall41() {
  int epidx = CkRegisterEp("addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49)",
      reinterpret_cast<CkCallFnPtr>(_call_addghostsendr1_marshall41), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_addghostsendr1_marshall41);

  return epidx;
}

void CkIndex_femMeshModify::_call_addghostsendr1_marshall41(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_addghostsendr1_marshall41, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_addghostsendr1_marshall41(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_47, int impl_noname_48, int impl_noname_49*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_47;
  implP|impl_noname_47;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_48;
  implP|impl_noname_48;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_49;
  implP|impl_noname_49;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->addghostsendr1(std::move(impl_noname_47.t), std::move(impl_noname_48.t), std::move(impl_noname_49.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_addghostsendr1_marshall41(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_47, int impl_noname_48, int impl_noname_49*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_47;
  implP|impl_noname_47;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_48;
  implP|impl_noname_48;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_49;
  implP|impl_noname_49;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_47");
  implDestP|impl_noname_47;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_48");
  implDestP|impl_noname_48;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_49");
  implDestP|impl_noname_49;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::addghostsendr1_41_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* willItLose(int impl_noname_4a, int impl_noname_4b);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_willItLose_marshall42() {
  int epidx = CkRegisterEp("willItLose(int impl_noname_4a, int impl_noname_4b)",
      reinterpret_cast<CkCallFnPtr>(_call_willItLose_marshall42), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_willItLose_marshall42);

  return epidx;
}

void CkIndex_femMeshModify::_call_willItLose_marshall42(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_willItLose_marshall42, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_willItLose_marshall42(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4a, int impl_noname_4b*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4a;
  implP|impl_noname_4a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4b;
  implP|impl_noname_4b;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->willItLose(std::move(impl_noname_4a.t), std::move(impl_noname_4b.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_willItLose_marshall42(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4a, int impl_noname_4b*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4a;
  implP|impl_noname_4a;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4b;
  implP|impl_noname_4b;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_4a");
  implDestP|impl_noname_4a;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_4b");
  implDestP|impl_noname_4b;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::willItLose_42_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_interpolateElemCopy_marshall43() {
  int epidx = CkRegisterEp("interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e)",
      reinterpret_cast<CkCallFnPtr>(_call_interpolateElemCopy_marshall43), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_interpolateElemCopy_marshall43);

  return epidx;
}

void CkIndex_femMeshModify::_call_interpolateElemCopy_marshall43(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_interpolateElemCopy_marshall43, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_interpolateElemCopy_marshall43(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4c, int impl_noname_4d, int impl_noname_4e*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4c;
  implP|impl_noname_4c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4d;
  implP|impl_noname_4d;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4e;
  implP|impl_noname_4e;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->interpolateElemCopy(std::move(impl_noname_4c.t), std::move(impl_noname_4d.t), std::move(impl_noname_4e.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_interpolateElemCopy_marshall43(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4c, int impl_noname_4d, int impl_noname_4e*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4c;
  implP|impl_noname_4c;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4d;
  implP|impl_noname_4d;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4e;
  implP|impl_noname_4e;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_4c");
  implDestP|impl_noname_4c;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_4d");
  implDestP|impl_noname_4d;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_4e");
  implDestP|impl_noname_4e;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::interpolateElemCopy_43_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void cleanupIDXL(int impl_noname_4f, int impl_noname_50);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_cleanupIDXL_marshall44() {
  int epidx = CkRegisterEp("cleanupIDXL(int impl_noname_4f, int impl_noname_50)",
      reinterpret_cast<CkCallFnPtr>(_call_cleanupIDXL_marshall44), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_cleanupIDXL_marshall44);

  return epidx;
}

void CkIndex_femMeshModify::_call_cleanupIDXL_marshall44(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_cleanupIDXL_marshall44, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_cleanupIDXL_marshall44(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4f, int impl_noname_50*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4f;
  implP|impl_noname_4f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_50;
  implP|impl_noname_50;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->cleanupIDXL(std::move(impl_noname_4f.t), std::move(impl_noname_50.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_cleanupIDXL_marshall44(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_4f, int impl_noname_50*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_4f;
  implP|impl_noname_4f;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_50;
  implP|impl_noname_50;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_4f");
  implDestP|impl_noname_4f;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_50");
  implDestP|impl_noname_50;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::cleanupIDXL_44_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void purgeElement(int impl_noname_51, int impl_noname_52);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_purgeElement_marshall45() {
  int epidx = CkRegisterEp("purgeElement(int impl_noname_51, int impl_noname_52)",
      reinterpret_cast<CkCallFnPtr>(_call_purgeElement_marshall45), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_purgeElement_marshall45);

  return epidx;
}

void CkIndex_femMeshModify::_call_purgeElement_marshall45(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_purgeElement_marshall45, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_purgeElement_marshall45(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_51, int impl_noname_52*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_51;
  implP|impl_noname_51;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_52;
  implP|impl_noname_52;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->purgeElement(std::move(impl_noname_51.t), std::move(impl_noname_52.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_purgeElement_marshall45(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_51, int impl_noname_52*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_51;
  implP|impl_noname_51;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_52;
  implP|impl_noname_52;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_51");
  implDestP|impl_noname_51;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_52");
  implDestP|impl_noname_52;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::purgeElement_45_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync entDataMsg* packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_packEntData_marshall46() {
  int epidx = CkRegisterEp("packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56)",
      reinterpret_cast<CkCallFnPtr>(_call_packEntData_marshall46), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_packEntData_marshall46);

  return epidx;
}

void CkIndex_femMeshModify::_call_packEntData_marshall46(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_packEntData_marshall46, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_packEntData_marshall46(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_53;
  implP|impl_noname_53;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_54;
  implP|impl_noname_54;
  PUP::detail::TemporaryObjectHolder<bool> impl_noname_55;
  implP|impl_noname_55;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_56;
  implP|impl_noname_56;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->packEntData(std::move(impl_noname_53.t), std::move(impl_noname_54.t), std::move(impl_noname_55.t), std::move(impl_noname_56.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_packEntData_marshall46(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_53;
  implP|impl_noname_53;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_54;
  implP|impl_noname_54;
  PUP::detail::TemporaryObjectHolder<bool> impl_noname_55;
  implP|impl_noname_55;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_56;
  implP|impl_noname_56;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_53");
  implDestP|impl_noname_53;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_54");
  implDestP|impl_noname_54;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_55");
  implDestP|impl_noname_55;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_56");
  implDestP|impl_noname_56;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::packEntData_46_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* isFixedNodeRemote(int impl_noname_57, int impl_noname_58);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_isFixedNodeRemote_marshall47() {
  int epidx = CkRegisterEp("isFixedNodeRemote(int impl_noname_57, int impl_noname_58)",
      reinterpret_cast<CkCallFnPtr>(_call_isFixedNodeRemote_marshall47), CkMarshallMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_isFixedNodeRemote_marshall47);

  return epidx;
}

void CkIndex_femMeshModify::_call_isFixedNodeRemote_marshall47(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_isFixedNodeRemote_marshall47, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_isFixedNodeRemote_marshall47(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_57, int impl_noname_58*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_57;
  implP|impl_noname_57;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_58;
  implP|impl_noname_58;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  void *impl_retMsg=(void *)   impl_obj->isFixedNodeRemote(std::move(impl_noname_57.t), std::move(impl_noname_58.t));
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  delete impl_msg_typed;
}
void CkIndex_femMeshModify::_marshallmessagepup_isFixedNodeRemote_marshall47(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int impl_noname_57, int impl_noname_58*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> impl_noname_57;
  implP|impl_noname_57;
  PUP::detail::TemporaryObjectHolder<int> impl_noname_58;
  implP|impl_noname_58;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("impl_noname_57");
  implDestP|impl_noname_57;
  if (implDestP.hasComments()) implDestP.comment("impl_noname_58");
  implDestP|impl_noname_58;
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::isFixedNodeRemote_47_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void finish();
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_finish_void() {
  int epidx = CkRegisterEp("finish()",
      reinterpret_cast<CkCallFnPtr>(_call_finish_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_femMeshModify::_call_finish_void(void* impl_msg, void* impl_obj_void)
{
  femMeshModify* impl_obj = static_cast<femMeshModify*>(impl_obj_void);
  CthThread tid = CthCreate((CthVoidFn)_callthr_finish_void, new CkThrCallArg(impl_msg,impl_obj), 0);
  ((Chare *)impl_obj)->CkAddThreadListeners(tid,impl_msg);
  CthTraceResume(tid);
  CthResume(tid);
}
void CkIndex_femMeshModify::_callthr_finish_void(CkThrCallArg *impl_arg)
{
  void *impl_msg = impl_arg->msg;
  void *impl_obj_void = impl_arg->obj;
  femMeshModify *impl_obj = static_cast<femMeshModify *>(impl_obj_void);
  delete impl_arg;
  int impl_ref = CkGetRefNum(impl_msg), impl_src = CkGetSrcPe(impl_msg);
  void *impl_retMsg=CkAllocSysMsg();
    impl_obj->finish();
  CkSendToFutureID(impl_ref, impl_retMsg, impl_src);
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
PUPable_def(SINGLE_ARG(Closure_femMeshModify::finish_48_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: femMeshModify(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_femMeshModify::reg_femMeshModify_CkMigrateMessage() {
  int epidx = CkRegisterEp("femMeshModify(CkMigrateMessage* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_femMeshModify_CkMigrateMessage), 0, __idx, 0);
  return epidx;
}

void CkIndex_femMeshModify::_call_femMeshModify_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<femMeshModify> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: femMeshModify(femMeshModMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void setFemMesh(FEMMeshMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* lockRemoteChunk(int2Msg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* unlockRemoteChunk(int2Msg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* addNodeRemote(addNodeMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addSharedNodeRemote(sharedNodeMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeSharedNodeRemote(removeSharedNodeMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addGhostElem(addGhostElemMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync chunkListMsg* getChunksSharingGhostNode(int2Msg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* addElementRemote(addElemMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeGhostElem(removeGhostElemMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeElementRemote(removeElemMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeGhostNode(int fromChk, int sharedIdx);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addToSharedList(int impl_noname_f, int impl_noname_10);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateAttrs(updateAttrsMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync double2Msg* getRemoteCoord(int impl_noname_11, int impl_noname_12);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getRemoteBound(int impl_noname_13, int impl_noname_14);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void idxllockRemote(int impl_noname_24, int impl_noname_25);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void idxlunlockRemote(int impl_noname_26, int impl_noname_27);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* eatIntoElement(int impl_noname_28, int impl_noname_29);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* getLockOwner(int impl_noname_2a, int impl_noname_2b);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync intMsg* hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void modifyLockAll(int impl_noname_32, int impl_noname_33);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void updateghostsend(verifyghostsendMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void verifyghostsend(verifyghostsendMsg* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync findgsMsg* findghostsend(int impl_noname_37, int impl_noname_38);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* willItLose(int impl_noname_4a, int impl_noname_4b);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void cleanupIDXL(int impl_noname_4f, int impl_noname_50);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void purgeElement(int impl_noname_51, int impl_noname_52);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync entDataMsg* packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync boolMsg* isFixedNodeRemote(int impl_noname_57, int impl_noname_58);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: threaded sync void finish();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: femMeshModify(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_femMeshModify::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 1);
  CkRegisterBase(__idx, CkIndex_ArrayElement::__idx);
  // REG: femMeshModify(femMeshModMsg* impl_msg);
  idx_femMeshModify_femMeshModMsg();

  // REG: threaded sync void setFemMesh(FEMMeshMsg* impl_msg);
  idx_setFemMesh_FEMMeshMsg();

  // REG: threaded sync intMsg* lockRemoteChunk(int2Msg* impl_msg);
  idx_lockRemoteChunk_int2Msg();

  // REG: threaded sync intMsg* unlockRemoteChunk(int2Msg* impl_msg);
  idx_unlockRemoteChunk_int2Msg();

  // REG: threaded sync intMsg* lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3);
  idx_lockRemoteNode_marshall5();

  // REG: threaded sync intMsg* unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7);
  idx_unlockRemoteNode_marshall6();

  // REG: threaded sync intMsg* addNodeRemote(addNodeMsg* impl_msg);
  idx_addNodeRemote_addNodeMsg();

  // REG: threaded sync void addSharedNodeRemote(sharedNodeMsg* impl_msg);
  idx_addSharedNodeRemote_sharedNodeMsg();

  // REG: threaded sync void removeSharedNodeRemote(removeSharedNodeMsg* impl_msg);
  idx_removeSharedNodeRemote_removeSharedNodeMsg();

  // REG: threaded sync void addGhostElem(addGhostElemMsg* impl_msg);
  idx_addGhostElem_addGhostElemMsg();

  // REG: threaded sync chunkListMsg* getChunksSharingGhostNode(int2Msg* impl_msg);
  idx_getChunksSharingGhostNode_int2Msg();

  // REG: threaded sync intMsg* addElementRemote(addElemMsg* impl_msg);
  idx_addElementRemote_addElemMsg();

  // REG: threaded sync void removeGhostElem(removeGhostElemMsg* impl_msg);
  idx_removeGhostElem_removeGhostElemMsg();

  // REG: threaded sync void removeElementRemote(removeElemMsg* impl_msg);
  idx_removeElementRemote_removeElemMsg();

  // REG: threaded sync void removeGhostNode(int fromChk, int sharedIdx);
  idx_removeGhostNode_marshall15();

  // REG: threaded sync void refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e);
  idx_refine_flip_element_leb_marshall16();

  // REG: threaded sync void addToSharedList(int impl_noname_f, int impl_noname_10);
  idx_addToSharedList_marshall17();

  // REG: threaded sync void updateAttrs(updateAttrsMsg* impl_msg);
  idx_updateAttrs_updateAttrsMsg();

  // REG: threaded sync double2Msg* getRemoteCoord(int impl_noname_11, int impl_noname_12);
  idx_getRemoteCoord_marshall19();

  // REG: threaded sync intMsg* getRemoteBound(int impl_noname_13, int impl_noname_14);
  idx_getRemoteBound_marshall20();

  // REG: threaded sync intMsg* getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17);
  idx_getIdxGhostSend_marshall21();

  // REG: threaded sync void updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a);
  idx_updateIdxlList_marshall22();

  // REG: threaded sync void removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d);
  idx_removeIDXLRemote_marshall23();

  // REG: threaded sync void addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20);
  idx_addTransIDXLRemote_marshall24();

  // REG: threaded sync void verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23);
  idx_verifyIdxlList_marshall25();

  // REG: threaded sync void idxllockRemote(int impl_noname_24, int impl_noname_25);
  idx_idxllockRemote_marshall26();

  // REG: threaded sync void idxlunlockRemote(int impl_noname_26, int impl_noname_27);
  idx_idxlunlockRemote_marshall27();

  // REG: threaded sync intMsg* eatIntoElement(int impl_noname_28, int impl_noname_29);
  idx_eatIntoElement_marshall28();

  // REG: threaded sync intMsg* getLockOwner(int impl_noname_2a, int impl_noname_2b);
  idx_getLockOwner_marshall29();

  // REG: threaded sync boolMsg* knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e);
  idx_knowsAbtNode_marshall30();

  // REG: threaded sync intMsg* hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31);
  idx_hasLockRemoteNode_marshall31();

  // REG: threaded sync void modifyLockAll(int impl_noname_32, int impl_noname_33);
  idx_modifyLockAll_marshall32();

  // REG: threaded sync boolMsg* verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36);
  idx_verifyLock_marshall33();

  // REG: threaded sync void updateghostsend(verifyghostsendMsg* impl_msg);
  idx_updateghostsend_verifyghostsendMsg();

  // REG: threaded sync void verifyghostsend(verifyghostsendMsg* impl_msg);
  idx_verifyghostsend_verifyghostsendMsg();

  // REG: threaded sync findgsMsg* findghostsend(int impl_noname_37, int impl_noname_38);
  idx_findghostsend_marshall36();

  // REG: threaded sync boolMsg* shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b);
  idx_shouldLoseGhost_marshall37();

  // REG: threaded sync void addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f);
  idx_addghostsendl_marshall38();

  // REG: threaded sync void addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42);
  idx_addghostsendl1_marshall39();

  // REG: threaded sync void addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46);
  idx_addghostsendr_marshall40();

  // REG: threaded sync void addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49);
  idx_addghostsendr1_marshall41();

  // REG: threaded sync boolMsg* willItLose(int impl_noname_4a, int impl_noname_4b);
  idx_willItLose_marshall42();

  // REG: threaded sync void interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e);
  idx_interpolateElemCopy_marshall43();

  // REG: threaded sync void cleanupIDXL(int impl_noname_4f, int impl_noname_50);
  idx_cleanupIDXL_marshall44();

  // REG: threaded sync void purgeElement(int impl_noname_51, int impl_noname_52);
  idx_purgeElement_marshall45();

  // REG: threaded sync entDataMsg* packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56);
  idx_packEntData_marshall46();

  // REG: threaded sync boolMsg* isFixedNodeRemote(int impl_noname_57, int impl_noname_58);
  idx_isFixedNodeRemote_marshall47();

  // REG: threaded sync void finish();
  idx_finish_void();

  // REG: femMeshModify(CkMigrateMessage* impl_msg);
  idx_femMeshModify_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_femMeshModify_CkMigrateMessage());

}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void _registerParFUM_Adapt(void)
{
  static int _done = 0; if(_done) return; _done = 1;
  CkRegisterReadonly("meshMod","CProxy_femMeshModify",sizeof(meshMod),(void *) &meshMod,__xlater_roPup_meshMod);

/* REG: message femMeshModMsg;
*/
CMessage_femMeshModMsg::__register("femMeshModMsg", sizeof(femMeshModMsg),(CkPackFnPtr) femMeshModMsg::pack,(CkUnpackFnPtr) femMeshModMsg::unpack);

/* REG: message FEMMeshMsg;
*/
CMessage_FEMMeshMsg::__register("FEMMeshMsg", sizeof(FEMMeshMsg),(CkPackFnPtr) FEMMeshMsg::pack,(CkUnpackFnPtr) FEMMeshMsg::unpack);

/* REG: message boolMsg;
*/
CMessage_boolMsg::__register("boolMsg", sizeof(boolMsg),(CkPackFnPtr) boolMsg::pack,(CkUnpackFnPtr) boolMsg::unpack);

/* REG: message intMsg;
*/
CMessage_intMsg::__register("intMsg", sizeof(intMsg),(CkPackFnPtr) intMsg::pack,(CkUnpackFnPtr) intMsg::unpack);

/* REG: message int2Msg;
*/
CMessage_int2Msg::__register("int2Msg", sizeof(int2Msg),(CkPackFnPtr) int2Msg::pack,(CkUnpackFnPtr) int2Msg::unpack);

/* REG: message double2Msg;
*/
CMessage_double2Msg::__register("double2Msg", sizeof(double2Msg),(CkPackFnPtr) double2Msg::pack,(CkUnpackFnPtr) double2Msg::unpack);

/* REG: message sharedNodeMsg{
int between[];
}
;
*/
CMessage_sharedNodeMsg::__register("sharedNodeMsg", sizeof(sharedNodeMsg),(CkPackFnPtr) sharedNodeMsg::pack,(CkUnpackFnPtr) sharedNodeMsg::unpack);

/* REG: message removeSharedNodeMsg;
*/
CMessage_removeSharedNodeMsg::__register("removeSharedNodeMsg", sizeof(removeSharedNodeMsg),(CkPackFnPtr) removeSharedNodeMsg::pack,(CkUnpackFnPtr) removeSharedNodeMsg::unpack);

/* REG: message addNodeMsg{
int between[];
int chunks[];
}
;
*/
CMessage_addNodeMsg::__register("addNodeMsg", sizeof(addNodeMsg),(CkPackFnPtr) addNodeMsg::pack,(CkUnpackFnPtr) addNodeMsg::unpack);

/* REG: message addGhostElemMsg{
int indices[];
int typeOfIndex[];
}
;
*/
CMessage_addGhostElemMsg::__register("addGhostElemMsg", sizeof(addGhostElemMsg),(CkPackFnPtr) addGhostElemMsg::pack,(CkUnpackFnPtr) addGhostElemMsg::unpack);

/* REG: message chunkListMsg{
int chunkList[];
int indexList[];
}
;
*/
CMessage_chunkListMsg::__register("chunkListMsg", sizeof(chunkListMsg),(CkPackFnPtr) chunkListMsg::pack,(CkUnpackFnPtr) chunkListMsg::unpack);

/* REG: message addElemMsg{
int conn[];
int ghostIndices[];
}
;
*/
CMessage_addElemMsg::__register("addElemMsg", sizeof(addElemMsg),(CkPackFnPtr) addElemMsg::pack,(CkUnpackFnPtr) addElemMsg::unpack);

/* REG: message removeGhostElemMsg{
int ghostIndices[];
int ghostRNIndices[];
int ghostREIndices[];
int sharedIndices[];
}
;
*/
CMessage_removeGhostElemMsg::__register("removeGhostElemMsg", sizeof(removeGhostElemMsg),(CkPackFnPtr) removeGhostElemMsg::pack,(CkUnpackFnPtr) removeGhostElemMsg::unpack);

/* REG: message removeElemMsg;
*/
CMessage_removeElemMsg::__register("removeElemMsg", sizeof(removeElemMsg),(CkPackFnPtr) removeElemMsg::pack,(CkUnpackFnPtr) removeElemMsg::unpack);

/* REG: message verifyghostsendMsg{
int chunks[];
}
;
*/
CMessage_verifyghostsendMsg::__register("verifyghostsendMsg", sizeof(verifyghostsendMsg),(CkPackFnPtr) verifyghostsendMsg::pack,(CkUnpackFnPtr) verifyghostsendMsg::unpack);

/* REG: message findgsMsg{
int chunks[];
}
;
*/
CMessage_findgsMsg::__register("findgsMsg", sizeof(findgsMsg),(CkPackFnPtr) findgsMsg::pack,(CkUnpackFnPtr) findgsMsg::unpack);

/* REG: message entDataMsg{
char data[];
}
;
*/
CMessage_entDataMsg::__register("entDataMsg", sizeof(entDataMsg),(CkPackFnPtr) entDataMsg::pack,(CkUnpackFnPtr) entDataMsg::unpack);

/* REG: message updateAttrsMsg{
char data[];
}
;
*/
CMessage_updateAttrsMsg::__register("updateAttrsMsg", sizeof(updateAttrsMsg),(CkPackFnPtr) updateAttrsMsg::pack,(CkUnpackFnPtr) updateAttrsMsg::unpack);

/* REG: array femMeshModify: ArrayElement{
femMeshModify(femMeshModMsg* impl_msg);
threaded sync void setFemMesh(FEMMeshMsg* impl_msg);
threaded sync intMsg* lockRemoteChunk(int2Msg* impl_msg);
threaded sync intMsg* unlockRemoteChunk(int2Msg* impl_msg);
threaded sync intMsg* lockRemoteNode(int impl_noname_0, int impl_noname_1, int impl_noname_2, int impl_noname_3);
threaded sync intMsg* unlockRemoteNode(int impl_noname_4, int impl_noname_5, int impl_noname_6, int impl_noname_7);
threaded sync intMsg* addNodeRemote(addNodeMsg* impl_msg);
threaded sync void addSharedNodeRemote(sharedNodeMsg* impl_msg);
threaded sync void removeSharedNodeRemote(removeSharedNodeMsg* impl_msg);
threaded sync void addGhostElem(addGhostElemMsg* impl_msg);
threaded sync chunkListMsg* getChunksSharingGhostNode(int2Msg* impl_msg);
threaded sync intMsg* addElementRemote(addElemMsg* impl_msg);
threaded sync void removeGhostElem(removeGhostElemMsg* impl_msg);
threaded sync void removeElementRemote(removeElemMsg* impl_msg);
threaded sync void removeGhostNode(int fromChk, int sharedIdx);
threaded sync void refine_flip_element_leb(int impl_noname_8, int impl_noname_9, int impl_noname_a, int impl_noname_b, int impl_noname_c, int impl_noname_d, double impl_noname_e);
threaded sync void addToSharedList(int impl_noname_f, int impl_noname_10);
threaded sync void updateAttrs(updateAttrsMsg* impl_msg);
threaded sync double2Msg* getRemoteCoord(int impl_noname_11, int impl_noname_12);
threaded sync intMsg* getRemoteBound(int impl_noname_13, int impl_noname_14);
threaded sync intMsg* getIdxGhostSend(int impl_noname_15, int impl_noname_16, int impl_noname_17);
threaded sync void updateIdxlList(int impl_noname_18, int impl_noname_19, int impl_noname_1a);
threaded sync void removeIDXLRemote(int impl_noname_1b, int impl_noname_1c, int impl_noname_1d);
threaded sync void addTransIDXLRemote(int impl_noname_1e, int impl_noname_1f, int impl_noname_20);
threaded sync void verifyIdxlList(int impl_noname_21, int impl_noname_22, int impl_noname_23);
threaded sync void idxllockRemote(int impl_noname_24, int impl_noname_25);
threaded sync void idxlunlockRemote(int impl_noname_26, int impl_noname_27);
threaded sync intMsg* eatIntoElement(int impl_noname_28, int impl_noname_29);
threaded sync intMsg* getLockOwner(int impl_noname_2a, int impl_noname_2b);
threaded sync boolMsg* knowsAbtNode(int impl_noname_2c, int impl_noname_2d, int impl_noname_2e);
threaded sync intMsg* hasLockRemoteNode(int impl_noname_2f, int impl_noname_30, int impl_noname_31);
threaded sync void modifyLockAll(int impl_noname_32, int impl_noname_33);
threaded sync boolMsg* verifyLock(int impl_noname_34, int impl_noname_35, int impl_noname_36);
threaded sync void updateghostsend(verifyghostsendMsg* impl_msg);
threaded sync void verifyghostsend(verifyghostsendMsg* impl_msg);
threaded sync findgsMsg* findghostsend(int impl_noname_37, int impl_noname_38);
threaded sync boolMsg* shouldLoseGhost(int impl_noname_39, int impl_noname_3a, int impl_noname_3b);
threaded sync void addghostsendl(int impl_noname_3c, int impl_noname_3d, int impl_noname_3e, int impl_noname_3f);
threaded sync void addghostsendl1(int impl_noname_40, int impl_noname_41, int impl_noname_42);
threaded sync void addghostsendr(int impl_noname_43, int impl_noname_44, int impl_noname_45, int impl_noname_46);
threaded sync void addghostsendr1(int impl_noname_47, int impl_noname_48, int impl_noname_49);
threaded sync boolMsg* willItLose(int impl_noname_4a, int impl_noname_4b);
threaded sync void interpolateElemCopy(int impl_noname_4c, int impl_noname_4d, int impl_noname_4e);
threaded sync void cleanupIDXL(int impl_noname_4f, int impl_noname_50);
threaded sync void purgeElement(int impl_noname_51, int impl_noname_52);
threaded sync entDataMsg* packEntData(int impl_noname_53, int impl_noname_54, const bool &impl_noname_55, int impl_noname_56);
threaded sync boolMsg* isFixedNodeRemote(int impl_noname_57, int impl_noname_58);
threaded sync void finish();
femMeshModify(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_femMeshModify::__register("femMeshModify", sizeof(femMeshModify));

}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_femMeshModify::virtual_pup(PUP::er &p) {
    recursive_pup<femMeshModify>(dynamic_cast<femMeshModify*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
