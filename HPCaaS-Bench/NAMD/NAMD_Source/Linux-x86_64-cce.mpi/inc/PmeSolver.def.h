


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_PmePencilXYZ::skip_3_closure : public SDAG::Closure {
      

      skip_3_closure() {
        init();
      }
      skip_3_closure(CkMigrateMessage*) {
        init();
      }
            void pup(PUP::er& __p) {
        packClosure(__p);
      }
      virtual ~skip_3_closure() {
      }
      PUPable_decl(SINGLE_ARG(skip_3_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */



/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_PmePencilXY::startDoneCallback_2_closure : public SDAG::Closure {
      

      startDoneCallback_2_closure() {
        init();
      }
      startDoneCallback_2_closure(CkMigrateMessage*) {
        init();
      }
            void pup(PUP::er& __p) {
        packClosure(__p);
      }
      virtual ~startDoneCallback_2_closure() {
      }
      PUPable_decl(SINGLE_ARG(startDoneCallback_2_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_PmePencilX::startDoneCallback_2_closure : public SDAG::Closure {
      

      startDoneCallback_2_closure() {
        init();
      }
      startDoneCallback_2_closure(CkMigrateMessage*) {
        init();
      }
            void pup(PUP::er& __p) {
        packClosure(__p);
      }
      virtual ~startDoneCallback_2_closure() {
      }
      PUPable_decl(SINGLE_ARG(startDoneCallback_2_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_PmePencilY::startDoneCallback_2_closure : public SDAG::Closure {
      

      startDoneCallback_2_closure() {
        init();
      }
      startDoneCallback_2_closure(CkMigrateMessage*) {
        init();
      }
            void pup(PUP::er& __p) {
        packClosure(__p);
      }
      virtual ~startDoneCallback_2_closure() {
      }
      PUPable_decl(SINGLE_ARG(startDoneCallback_2_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* ---------------- method closures -------------- */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_PmePencilZ::startDoneCallback_2_closure : public SDAG::Closure {
      

      startDoneCallback_2_closure() {
        init();
      }
      startDoneCallback_2_closure(CkMigrateMessage*) {
        init();
      }
            void pup(PUP::er& __p) {
        packClosure(__p);
      }
      virtual ~startDoneCallback_2_closure() {
      }
      PUPable_decl(SINGLE_ARG(startDoneCallback_2_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY

    struct Closure_PmePencilZ::skip_4_closure : public SDAG::Closure {
      

      skip_4_closure() {
        init();
      }
      skip_4_closure(CkMigrateMessage*) {
        init();
      }
            void pup(PUP::er& __p) {
        packClosure(__p);
      }
      virtual ~skip_4_closure() {
      }
      PUPable_decl(SINGLE_ARG(skip_4_closure));
    };
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */


/* DEFS: message PmeStartMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_PmeStartMsg::operator new(size_t s){
  return PmeStartMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_PmeStartMsg::operator new(size_t s, int* sz){
  return PmeStartMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_PmeStartMsg::operator new(size_t s, int* sz,const int pb){
  return PmeStartMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_PmeStartMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return PmeStartMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_PmeStartMsg::operator new(size_t s, const int p) {
  return PmeStartMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_PmeStartMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return PmeStartMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_PmeStartMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_PmeStartMsg::CMessage_PmeStartMsg() {
PmeStartMsg *newmsg = (PmeStartMsg *)this;
}
void CMessage_PmeStartMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_PmeStartMsg::pack(PmeStartMsg *msg) {
  return (void *) msg;
}
PmeStartMsg* CMessage_PmeStartMsg::unpack(void* buf) {
  PmeStartMsg *msg = (PmeStartMsg *) buf;
  return msg;
}
int CMessage_PmeStartMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message PmeRunMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_PmeRunMsg::operator new(size_t s){
  return PmeRunMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_PmeRunMsg::operator new(size_t s, int* sz){
  return PmeRunMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_PmeRunMsg::operator new(size_t s, int* sz,const int pb){
  return PmeRunMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_PmeRunMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return PmeRunMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_PmeRunMsg::operator new(size_t s, const int p) {
  return PmeRunMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_PmeRunMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return PmeRunMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_PmeRunMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_PmeRunMsg::CMessage_PmeRunMsg() {
PmeRunMsg *newmsg = (PmeRunMsg *)this;
}
void CMessage_PmeRunMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_PmeRunMsg::pack(PmeRunMsg *msg) {
  return (void *) msg;
}
PmeRunMsg* CMessage_PmeRunMsg::unpack(void* buf) {
  PmeRunMsg *msg = (PmeRunMsg *) buf;
  return msg;
}
int CMessage_PmeRunMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: message PmeDoneMsg;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_PmeDoneMsg::operator new(size_t s){
  return PmeDoneMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_PmeDoneMsg::operator new(size_t s, int* sz){
  return PmeDoneMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_PmeDoneMsg::operator new(size_t s, int* sz,const int pb){
  return PmeDoneMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_PmeDoneMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return PmeDoneMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_PmeDoneMsg::operator new(size_t s, const int p) {
  return PmeDoneMsg::alloc(__idx, s, 0, p, GroupDepNum{});
}
void *CMessage_PmeDoneMsg::operator new(size_t s, const int p, const GroupDepNum groupDepNum) {
  return PmeDoneMsg::alloc(__idx, s, 0, p, groupDepNum);
}
void* CMessage_PmeDoneMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[0], pb, groupDepNum);
}
CMessage_PmeDoneMsg::CMessage_PmeDoneMsg() {
PmeDoneMsg *newmsg = (PmeDoneMsg *)this;
}
void CMessage_PmeDoneMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_PmeDoneMsg::pack(PmeDoneMsg *msg) {
  return (void *) msg;
}
PmeDoneMsg* CMessage_PmeDoneMsg::unpack(void* buf) {
  PmeDoneMsg *msg = (PmeDoneMsg *) buf;
  return msg;
}
int CMessage_PmeDoneMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: group PmePencilXYZMap: CkArrayMap{
PmePencilXYZMap(int pe);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilXYZMap::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZMap(int pe);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZMap(int pe);
 */
CkGroupID CProxy_PmePencilXYZMap::ckNew(int pe, const CkEntryOptions *impl_e_opts)
{
  //Marshall: int pe
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|pe;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|pe;
  }
  UsrToEnv(impl_msg)->setMsgtype(BocInitMsg);
  CkGroupID gId = CkCreateGroup(CkIndex_PmePencilXYZMap::__idx, CkIndex_PmePencilXYZMap::idx_PmePencilXYZMap_marshall1(), impl_msg);
  return gId;
}
  CProxy_PmePencilXYZMap::CProxy_PmePencilXYZMap(int pe, const CkEntryOptions *impl_e_opts)
{
  //Marshall: int pe
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|pe;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|pe;
  }
  UsrToEnv(impl_msg)->setMsgtype(BocInitMsg);
  ckSetGroupID(CkCreateGroup(CkIndex_PmePencilXYZMap::__idx, CkIndex_PmePencilXYZMap::idx_PmePencilXYZMap_marshall1(), impl_msg));
}

// Entry point registration function
int CkIndex_PmePencilXYZMap::reg_PmePencilXYZMap_marshall1() {
  int epidx = CkRegisterEp("PmePencilXYZMap(int pe)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilXYZMap_marshall1), CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_PmePencilXYZMap_marshall1);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_PmePencilXYZMap_marshall1);

  return epidx;
}

void CkIndex_PmePencilXYZMap::_call_PmePencilXYZMap_marshall1(void* impl_msg, void* impl_obj_void)
{
  PmePencilXYZMap* impl_obj = static_cast<PmePencilXYZMap*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int pe*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> pe;
  implP|pe;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  new (impl_obj_void) PmePencilXYZMap(std::move(pe.t));
}
int CkIndex_PmePencilXYZMap::_callmarshall_PmePencilXYZMap_marshall1(char* impl_buf, void* impl_obj_void) {
  PmePencilXYZMap* impl_obj = static_cast<PmePencilXYZMap*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  /*Unmarshall pup'd fields: int pe*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> pe;
  implP|pe;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  new (impl_obj_void) PmePencilXYZMap(std::move(pe.t));
  return implP.size();
}
void CkIndex_PmePencilXYZMap::_marshallmessagepup_PmePencilXYZMap_marshall1(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int pe*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> pe;
  implP|pe;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("pe");
  implDestP|pe;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZMap(int pe);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilXYZMap::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeGroup);
  CkRegisterBase(__idx, CkIndex_CkArrayMap::__idx);
   CkRegisterGroupIrr(__idx,PmePencilXYZMap::isIrreducible());
  // REG: PmePencilXYZMap(int pe);
  idx_PmePencilXYZMap_marshall1();

}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: group PmePencilXMap: CkArrayMap{
PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilXMap::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes);
 */
CkGroupID CProxy_PmePencilXMap::ckNew(int ia, int ib, int width, const std::vector<int> &pes, const CkEntryOptions *impl_e_opts)
{
  //Marshall: int ia, int ib, int width, const std::vector<int> &pes
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|ia;
    implP|ib;
    implP|width;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|ia;
    implP|ib;
    implP|width;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
  }
  UsrToEnv(impl_msg)->setMsgtype(BocInitMsg);
  CkGroupID gId = CkCreateGroup(CkIndex_PmePencilXMap::__idx, CkIndex_PmePencilXMap::idx_PmePencilXMap_marshall1(), impl_msg);
  return gId;
}
  CProxy_PmePencilXMap::CProxy_PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes, const CkEntryOptions *impl_e_opts)
{
  //Marshall: int ia, int ib, int width, const std::vector<int> &pes
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    implP|ia;
    implP|ib;
    implP|width;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    implP|ia;
    implP|ib;
    implP|width;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
  }
  UsrToEnv(impl_msg)->setMsgtype(BocInitMsg);
  ckSetGroupID(CkCreateGroup(CkIndex_PmePencilXMap::__idx, CkIndex_PmePencilXMap::idx_PmePencilXMap_marshall1(), impl_msg));
}

// Entry point registration function
int CkIndex_PmePencilXMap::reg_PmePencilXMap_marshall1() {
  int epidx = CkRegisterEp("PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilXMap_marshall1), CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_PmePencilXMap_marshall1);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_PmePencilXMap_marshall1);

  return epidx;
}

void CkIndex_PmePencilXMap::_call_PmePencilXMap_marshall1(void* impl_msg, void* impl_obj_void)
{
  PmePencilXMap* impl_obj = static_cast<PmePencilXMap*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int ia, int ib, int width, const std::vector<int> &pes*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> ia;
  implP|ia;
  PUP::detail::TemporaryObjectHolder<int> ib;
  implP|ib;
  PUP::detail::TemporaryObjectHolder<int> width;
  implP|width;
  PUP::detail::TemporaryObjectHolder<std::vector<int>> pes;
  implP|pes;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  new (impl_obj_void) PmePencilXMap(std::move(ia.t), std::move(ib.t), std::move(width.t), std::move(pes.t));
}
int CkIndex_PmePencilXMap::_callmarshall_PmePencilXMap_marshall1(char* impl_buf, void* impl_obj_void) {
  PmePencilXMap* impl_obj = static_cast<PmePencilXMap*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  /*Unmarshall pup'd fields: int ia, int ib, int width, const std::vector<int> &pes*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> ia;
  implP|ia;
  PUP::detail::TemporaryObjectHolder<int> ib;
  implP|ib;
  PUP::detail::TemporaryObjectHolder<int> width;
  implP|width;
  PUP::detail::TemporaryObjectHolder<std::vector<int>> pes;
  implP|pes;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  new (impl_obj_void) PmePencilXMap(std::move(ia.t), std::move(ib.t), std::move(width.t), std::move(pes.t));
  return implP.size();
}
void CkIndex_PmePencilXMap::_marshallmessagepup_PmePencilXMap_marshall1(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: int ia, int ib, int width, const std::vector<int> &pes*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<int> ia;
  implP|ia;
  PUP::detail::TemporaryObjectHolder<int> ib;
  implP|ib;
  PUP::detail::TemporaryObjectHolder<int> width;
  implP|width;
  PUP::detail::TemporaryObjectHolder<std::vector<int>> pes;
  implP|pes;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("ia");
  implDestP|ia;
  if (implDestP.hasComments()) implDestP.comment("ib");
  implDestP|ib;
  if (implDestP.hasComments()) implDestP.comment("width");
  implDestP|width;
  if (implDestP.hasComments()) implDestP.comment("pes");
  implDestP|pes;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilXMap::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeGroup);
  CkRegisterBase(__idx, CkIndex_CkArrayMap::__idx);
   CkRegisterGroupIrr(__idx,PmePencilXMap::isIrreducible());
  // REG: PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes);
  idx_PmePencilXMap_marshall1();

}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: group PmePencilXYMap: CkArrayMap{
PmePencilXYMap(const std::vector<int> &pes);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilXYMap::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYMap(const std::vector<int> &pes);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYMap(const std::vector<int> &pes);
 */
CkGroupID CProxy_PmePencilXYMap::ckNew(const std::vector<int> &pes, const CkEntryOptions *impl_e_opts)
{
  //Marshall: const std::vector<int> &pes
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
  }
  UsrToEnv(impl_msg)->setMsgtype(BocInitMsg);
  CkGroupID gId = CkCreateGroup(CkIndex_PmePencilXYMap::__idx, CkIndex_PmePencilXYMap::idx_PmePencilXYMap_marshall1(), impl_msg);
  return gId;
}
  CProxy_PmePencilXYMap::CProxy_PmePencilXYMap(const std::vector<int> &pes, const CkEntryOptions *impl_e_opts)
{
  //Marshall: const std::vector<int> &pes
  int impl_off=0;
  { //Find the size of the PUP'd data
    PUP::sizer implP;
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
    impl_off+=implP.size();
  }
  CkMarshallMsg *impl_msg=CkAllocateMarshallMsg(impl_off,impl_e_opts);
  { //Copy over the PUP'd data
    PUP::toMem implP((void *)impl_msg->msgBuf);
    //Have to cast away const-ness to get pup routine
    implP|(typename std::remove_cv<typename std::remove_reference<std::vector<int>>::type>::type &)pes;
  }
  UsrToEnv(impl_msg)->setMsgtype(BocInitMsg);
  ckSetGroupID(CkCreateGroup(CkIndex_PmePencilXYMap::__idx, CkIndex_PmePencilXYMap::idx_PmePencilXYMap_marshall1(), impl_msg));
}

// Entry point registration function
int CkIndex_PmePencilXYMap::reg_PmePencilXYMap_marshall1() {
  int epidx = CkRegisterEp("PmePencilXYMap(const std::vector<int> &pes)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilXYMap_marshall1), CkMarshallMsg::__idx, __idx, 0+CK_EP_NOKEEP);
  CkRegisterMarshallUnpackFn(epidx, _callmarshall_PmePencilXYMap_marshall1);
  CkRegisterMessagePupFn(epidx, _marshallmessagepup_PmePencilXYMap_marshall1);

  return epidx;
}

void CkIndex_PmePencilXYMap::_call_PmePencilXYMap_marshall1(void* impl_msg, void* impl_obj_void)
{
  PmePencilXYMap* impl_obj = static_cast<PmePencilXYMap*>(impl_obj_void);
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: const std::vector<int> &pes*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<std::vector<int>> pes;
  implP|pes;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  new (impl_obj_void) PmePencilXYMap(std::move(pes.t));
}
int CkIndex_PmePencilXYMap::_callmarshall_PmePencilXYMap_marshall1(char* impl_buf, void* impl_obj_void) {
  PmePencilXYMap* impl_obj = static_cast<PmePencilXYMap*>(impl_obj_void);
  envelope *env = UsrToEnv(impl_buf);
  /*Unmarshall pup'd fields: const std::vector<int> &pes*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<std::vector<int>> pes;
  implP|pes;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  new (impl_obj_void) PmePencilXYMap(std::move(pes.t));
  return implP.size();
}
void CkIndex_PmePencilXYMap::_marshallmessagepup_PmePencilXYMap_marshall1(PUP::er &implDestP,void *impl_msg) {
  CkMarshallMsg *impl_msg_typed=(CkMarshallMsg *)impl_msg;
  char *impl_buf=impl_msg_typed->msgBuf;
  envelope *env = UsrToEnv(impl_msg_typed);
  /*Unmarshall pup'd fields: const std::vector<int> &pes*/
  PUP::fromMem implP(impl_buf);
  PUP::detail::TemporaryObjectHolder<std::vector<int>> pes;
  implP|pes;
  impl_buf+=CK_ALIGN(implP.size(),16);
  /*Unmarshall arrays:*/
  if (implDestP.hasComments()) implDestP.comment("pes");
  implDestP|pes;
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYMap(const std::vector<int> &pes);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilXYMap::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeGroup);
  CkRegisterBase(__idx, CkIndex_CkArrayMap::__idx);
   CkRegisterGroupIrr(__idx,PmePencilXYMap::isIrreducible());
  // REG: PmePencilXYMap(const std::vector<int> &pes);
  idx_PmePencilXYMap_marshall1();

}
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: array PmePencilXYZ: ArrayElement{
PmePencilXYZ();
void chargeGridReady(PmeRunMsg* impl_msg);
void skip();
void start(PmeStartMsg* impl_msg);
PmePencilXYZ(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilXYZ::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_PmePencilXYZ::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_PmePencilXYZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilXYZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_PmePencilXYZ::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_PmePencilXYZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilXYZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZ();
 */
void CProxyElement_PmePencilXYZ::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_PmePencilXYZ::idx_PmePencilXYZ_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxyElement_PmePencilXYZ::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXYZ::idx_chargeGridReady_PmeRunMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void skip();
 */
void CProxyElement_PmePencilXYZ::skip(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXYZ::idx_skip_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxyElement_PmePencilXYZ::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXYZ::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZ();
 */
CkArrayID CProxy_PmePencilXYZ::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilXYZ::idx_PmePencilXYZ_void(), opts);
  return gId;
}
void CProxy_PmePencilXYZ::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilXYZ::idx_PmePencilXYZ_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_PmePencilXYZ::ckNew(const int s1, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilXYZ::idx_PmePencilXYZ_void(), opts);
  return gId;
}
void CProxy_PmePencilXYZ::ckNew(const int s1, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilXYZ::idx_PmePencilXYZ_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_PmePencilXYZ::reg_PmePencilXYZ_void() {
  int epidx = CkRegisterEp("PmePencilXYZ()",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilXYZ_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilXYZ::_call_PmePencilXYZ_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilXYZ* impl_obj = static_cast<PmePencilXYZ*>(impl_obj_void);
  new (impl_obj_void) PmePencilXYZ();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxy_PmePencilXYZ::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilXYZ::idx_chargeGridReady_PmeRunMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilXYZ::reg_chargeGridReady_PmeRunMsg() {
  int epidx = CkRegisterEp("chargeGridReady(PmeRunMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_chargeGridReady_PmeRunMsg), CMessage_PmeRunMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeRunMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilXYZ::_call_chargeGridReady_PmeRunMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilXYZ* impl_obj = static_cast<PmePencilXYZ*>(impl_obj_void);
  impl_obj->chargeGridReady((PmeRunMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void skip();
 */
void CProxy_PmePencilXYZ::skip(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilXYZ::idx_skip_void(),0);
}

// Entry point registration function
int CkIndex_PmePencilXYZ::reg_skip_void() {
  int epidx = CkRegisterEp("skip()",
      reinterpret_cast<CkCallFnPtr>(_call_skip_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilXYZ::_call_skip_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilXYZ* impl_obj = static_cast<PmePencilXYZ*>(impl_obj_void);
  impl_obj->skip();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
PUPable_def(SINGLE_ARG(Closure_PmePencilXYZ::skip_3_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxy_PmePencilXYZ::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilXYZ::idx_start_PmeStartMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilXYZ::reg_start_PmeStartMsg() {
  int epidx = CkRegisterEp("start(PmeStartMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_start_PmeStartMsg), CMessage_PmeStartMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeStartMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilXYZ::_call_start_PmeStartMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilXYZ* impl_obj = static_cast<PmePencilXYZ*>(impl_obj_void);
  impl_obj->_sdag_fnc_start((PmeStartMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZ(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_PmePencilXYZ::reg_PmePencilXYZ_CkMigrateMessage() {
  int epidx = CkRegisterEp("PmePencilXYZ(CkMigrateMessage* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilXYZ_CkMigrateMessage), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilXYZ::_call_PmePencilXYZ_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<PmePencilXYZ> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZ();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxySection_PmePencilXYZ::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXYZ::idx_chargeGridReady_PmeRunMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void skip();
 */
void CProxySection_PmePencilXYZ::skip(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXYZ::idx_skip_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxySection_PmePencilXYZ::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXYZ::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXYZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilXYZ::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 1);
  CkRegisterBase(__idx, CkIndex_ArrayElement::__idx);
  // REG: PmePencilXYZ();
  idx_PmePencilXYZ_void();
  CkRegisterDefaultCtor(__idx, idx_PmePencilXYZ_void());

  // REG: void chargeGridReady(PmeRunMsg* impl_msg);
  idx_chargeGridReady_PmeRunMsg();

  // REG: void skip();
  idx_skip_void();

  // REG: void start(PmeStartMsg* impl_msg);
  idx_start_PmeStartMsg();

  // REG: PmePencilXYZ(CkMigrateMessage* impl_msg);
  idx_PmePencilXYZ_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_PmePencilXYZ_CkMigrateMessage());

  PmePencilXYZ::__sdag_register(); // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::start(PmeStartMsg pmeStartMsg){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "PmePencilXYZ", "start(PmeStartMsg pmeStartMsg)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_sdag_fnc_start(PmeStartMsg* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(gen0);
  _slist_0(gen0);
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::start_end(PmeStartMsg* gen0) {
  CmiFree(UsrToEnv(gen0));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_slist_0(PmeStartMsg* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_slist_0_end(PmeStartMsg* gen0) {
  start_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_serial_0(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXYZ_initFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 19 "inc/PmeSolver.ci"

        initFFT(pmeStartMsg);
        delete pmeStartMsg;
      
#line 1143 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _while_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_while_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_while_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_slist_1(PmeStartMsg* gen0) {
  _when_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_slist_1_end(PmeStartMsg* gen0) {
  _while_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilXYZ::_when_0(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_1(gen0, static_cast<PmeRunMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_when_0_end(PmeStartMsg* gen0, PmeRunMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeRunMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _serial_2(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_serial_1(PmeStartMsg* gen0, PmeRunMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXYZ_forwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeRunMsg*& msg = gen1;
      { // begin serial block
#line 24 "inc/PmeSolver.ci"

          doEnergy = msg->doEnergy;
          doVirial = msg->doVirial;
          lattice = msg->lattice;
          numStrayAtoms = msg->numStrayAtoms;
          delete msg;
          forwardFFT();
        
#line 1245 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_serial_2(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXYZ_forwardDone()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 32 "inc/PmeSolver.ci"
 forwardDone(); 
#line 1264 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_3(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_serial_3(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXYZ_backwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 33 "inc/PmeSolver.ci"
 backwardFFT(); 
#line 1282 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_4(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_serial_4(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXYZ_backwardDone()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 34 "inc/PmeSolver.ci"
 backwardDone(); 
#line 1300 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::chargeGridReady(PmeRunMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(msg_msg);
  __dep->pushBuffer(0, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_sdag_init() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(1,1));
  __dep->addDepends(0,0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::__sdag_init() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::_sdag_pup(PUP::er &p) {  // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXYZ::__sdag_register() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  (void)_sdag_idx_PmePencilXYZ_initFFT();
  (void)_sdag_idx_PmePencilXYZ_forwardFFT();
  (void)_sdag_idx_PmePencilXYZ_forwardDone();
  (void)_sdag_idx_PmePencilXYZ_backwardFFT();
  (void)_sdag_idx_PmePencilXYZ_backwardDone();
  PUPable_reg(SINGLE_ARG(Closure_PmePencilXYZ::skip_3_closure));
  PUPable_reg(SINGLE_ARG(Closure_PmePencilXYZ::skip_3_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_idx_PmePencilXYZ_initFFT() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXYZ_initFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_reg_PmePencilXYZ_initFFT() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXYZ_initFFT", NULL, 0, CkIndex_PmePencilXYZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_idx_PmePencilXYZ_forwardFFT() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXYZ_forwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_reg_PmePencilXYZ_forwardFFT() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXYZ_forwardFFT", NULL, 0, CkIndex_PmePencilXYZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_idx_PmePencilXYZ_forwardDone() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXYZ_forwardDone();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_reg_PmePencilXYZ_forwardDone() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXYZ_forwardDone", NULL, 0, CkIndex_PmePencilXYZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_idx_PmePencilXYZ_backwardFFT() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXYZ_backwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_reg_PmePencilXYZ_backwardFFT() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXYZ_backwardFFT", NULL, 0, CkIndex_PmePencilXYZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_idx_PmePencilXYZ_backwardDone() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXYZ_backwardDone();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXYZ::_sdag_reg_PmePencilXYZ_backwardDone() { // Potentially missing PmePencilXYZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXYZ_backwardDone", NULL, 0, CkIndex_PmePencilXYZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: message PmeBlockMsg{
float2 data[];
}
;
 */
#ifndef CK_TEMPLATES_ONLY
void *CMessage_PmeBlockMsg::operator new(size_t s){
  return PmeBlockMsg::alloc(__idx, s, 0, 0, GroupDepNum{});
}
void *CMessage_PmeBlockMsg::operator new(size_t s, int* sz){
  return PmeBlockMsg::alloc(__idx, s, sz, 0, GroupDepNum{});
}
void *CMessage_PmeBlockMsg::operator new(size_t s, int* sz,const int pb){
  return PmeBlockMsg::alloc(__idx, s, sz, pb, GroupDepNum{});
}
void *CMessage_PmeBlockMsg::operator new(size_t s, int* sz,const int pb, const GroupDepNum groupDepNum){
  return PmeBlockMsg::alloc(__idx, s, sz, pb, groupDepNum);
}
void *CMessage_PmeBlockMsg::operator new(size_t s, int sz0) {
  int sizes[1];
  sizes[0] = sz0;
  return PmeBlockMsg::alloc(__idx, s, sizes, 0, GroupDepNum{});
}
void *CMessage_PmeBlockMsg::operator new(size_t s, int sz0, const int p) {
  int sizes[1];
  sizes[0] = sz0;
  return PmeBlockMsg::alloc(__idx, s, sizes, p, GroupDepNum{});
}
void *CMessage_PmeBlockMsg::operator new(size_t s, int sz0, const int p, const GroupDepNum groupDepNum) {
  int sizes[1];
  sizes[0] = sz0;
  return PmeBlockMsg::alloc(__idx, s, sizes, p, groupDepNum);
}
void* CMessage_PmeBlockMsg::alloc(int msgnum, size_t sz, int *sizes, int pb, GroupDepNum groupDepNum) {
  CkpvAccess(_offsets)[0] = ALIGN_DEFAULT(sz);
  if(sizes==0)
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0];
  else
    CkpvAccess(_offsets)[1] = CkpvAccess(_offsets)[0] + ALIGN_DEFAULT(sizeof(float2)*sizes[0]);
  return CkAllocMsg(msgnum, CkpvAccess(_offsets)[1], pb, groupDepNum);
}
CMessage_PmeBlockMsg::CMessage_PmeBlockMsg() {
PmeBlockMsg *newmsg = (PmeBlockMsg *)this;
  newmsg->data = (float2 *) ((char *)newmsg + CkpvAccess(_offsets)[0]);
}
void CMessage_PmeBlockMsg::dealloc(void *p) {
  CkFreeMsg(p);
}
void* CMessage_PmeBlockMsg::pack(PmeBlockMsg *msg) {
  msg->data = (float2 *) ((char *)msg->data - (char *)msg);
  return (void *) msg;
}
PmeBlockMsg* CMessage_PmeBlockMsg::unpack(void* buf) {
  PmeBlockMsg *msg = (PmeBlockMsg *) buf;
  msg->data = (float2 *) ((size_t)msg->data + (char *)msg);
  return msg;
}
int CMessage_PmeBlockMsg::__idx=0;
#endif /* CK_TEMPLATES_ONLY */

/* DEFS: array PmePencilXY: ArrayElement{
PmePencilXY();
void startDoneCallback();
void chargeGridReady(PmeRunMsg* impl_msg);
void recvBlock(PmeBlockMsg* impl_msg);
void start(PmeStartMsg* impl_msg);
PmePencilXY(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilXY::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_PmePencilXY::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_PmePencilXY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilXY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_PmePencilXY::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_PmePencilXY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilXY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXY();
 */
void CProxyElement_PmePencilXY::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_PmePencilXY::idx_PmePencilXY_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxyElement_PmePencilXY::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxyElement_PmePencilXY::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_chargeGridReady_PmeRunMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxyElement_PmePencilXY::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxyElement_PmePencilXY::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXY();
 */
CkArrayID CProxy_PmePencilXY::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilXY::idx_PmePencilXY_void(), opts);
  return gId;
}
void CProxy_PmePencilXY::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilXY::idx_PmePencilXY_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_PmePencilXY::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilXY::idx_PmePencilXY_void(), opts);
  return gId;
}
void CProxy_PmePencilXY::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilXY::idx_PmePencilXY_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_PmePencilXY::reg_PmePencilXY_void() {
  int epidx = CkRegisterEp("PmePencilXY()",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilXY_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilXY::_call_PmePencilXY_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilXY* impl_obj = static_cast<PmePencilXY*>(impl_obj_void);
  new (impl_obj_void) PmePencilXY();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxy_PmePencilXY::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilXY::idx_startDoneCallback_void(),0);
}

// Entry point registration function
int CkIndex_PmePencilXY::reg_startDoneCallback_void() {
  int epidx = CkRegisterEp("startDoneCallback()",
      reinterpret_cast<CkCallFnPtr>(_call_startDoneCallback_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilXY::_call_startDoneCallback_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilXY* impl_obj = static_cast<PmePencilXY*>(impl_obj_void);
  impl_obj->startDoneCallback();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
PUPable_def(SINGLE_ARG(Closure_PmePencilXY::startDoneCallback_2_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxy_PmePencilXY::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilXY::idx_chargeGridReady_PmeRunMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilXY::reg_chargeGridReady_PmeRunMsg() {
  int epidx = CkRegisterEp("chargeGridReady(PmeRunMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_chargeGridReady_PmeRunMsg), CMessage_PmeRunMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeRunMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilXY::_call_chargeGridReady_PmeRunMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilXY* impl_obj = static_cast<PmePencilXY*>(impl_obj_void);
  impl_obj->chargeGridReady((PmeRunMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxy_PmePencilXY::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilXY::idx_recvBlock_PmeBlockMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilXY::reg_recvBlock_PmeBlockMsg() {
  int epidx = CkRegisterEp("recvBlock(PmeBlockMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_recvBlock_PmeBlockMsg), CMessage_PmeBlockMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeBlockMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilXY::_call_recvBlock_PmeBlockMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilXY* impl_obj = static_cast<PmePencilXY*>(impl_obj_void);
  impl_obj->recvBlock((PmeBlockMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxy_PmePencilXY::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilXY::idx_start_PmeStartMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilXY::reg_start_PmeStartMsg() {
  int epidx = CkRegisterEp("start(PmeStartMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_start_PmeStartMsg), CMessage_PmeStartMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeStartMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilXY::_call_start_PmeStartMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilXY* impl_obj = static_cast<PmePencilXY*>(impl_obj_void);
  impl_obj->_sdag_fnc_start((PmeStartMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXY(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_PmePencilXY::reg_PmePencilXY_CkMigrateMessage() {
  int epidx = CkRegisterEp("PmePencilXY(CkMigrateMessage* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilXY_CkMigrateMessage), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilXY::_call_PmePencilXY_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<PmePencilXY> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXY();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxySection_PmePencilXY::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxySection_PmePencilXY::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_chargeGridReady_PmeRunMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxySection_PmePencilXY::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxySection_PmePencilXY::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilXY::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilXY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilXY::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_ArrayElement::__idx);
  // REG: PmePencilXY();
  idx_PmePencilXY_void();
  CkRegisterDefaultCtor(__idx, idx_PmePencilXY_void());

  // REG: void startDoneCallback();
  idx_startDoneCallback_void();

  // REG: void chargeGridReady(PmeRunMsg* impl_msg);
  idx_chargeGridReady_PmeRunMsg();

  // REG: void recvBlock(PmeBlockMsg* impl_msg);
  idx_recvBlock_PmeBlockMsg();

  // REG: void start(PmeStartMsg* impl_msg);
  idx_start_PmeStartMsg();

  // REG: PmePencilXY(CkMigrateMessage* impl_msg);
  idx_PmePencilXY_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_PmePencilXY_CkMigrateMessage());

  PmePencilXY::__sdag_register(); // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::start(PmeStartMsg pmeStartMsg){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "PmePencilXY", "start(PmeStartMsg pmeStartMsg)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_sdag_fnc_start(PmeStartMsg* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(gen0);
  _slist_0(gen0);
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::start_end(PmeStartMsg* gen0) {
  CmiFree(UsrToEnv(gen0));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_slist_0(PmeStartMsg* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_slist_0_end(PmeStartMsg* gen0) {
  start_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_serial_0(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXY_initFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 47 "inc/PmeSolver.ci"

        initFFT(pmeStartMsg);
        delete pmeStartMsg;
        start(CkCallback(CkIndex_PmePencilXY::startDoneCallback(), thisProxy[thisIndex]));
      
#line 1946 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _when_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilXY::_when_0(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_1(gen0);
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_when_0_end(PmeStartMsg* gen0) {
  _while_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_serial_1(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXY_serial_1()), CkMyPe(), 0, &projID, this); 
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_while_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_while_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_slist_1(PmeStartMsg* gen0) {
  _when_1(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_slist_1_end(PmeStartMsg* gen0) {
  _while_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilXY::_when_1(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, static_cast<PmeRunMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_when_1_end(PmeStartMsg* gen0, PmeRunMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeRunMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _for_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_serial_2(PmeStartMsg* gen0, PmeRunMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXY_forwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeRunMsg*& msg = gen1;
      { // begin serial block
#line 54 "inc/PmeSolver.ci"

          doEnergy = msg->doEnergy;
          doVirial = msg->doVirial;
          lattice = msg->lattice;
          numStrayAtoms = msg->numStrayAtoms;
          delete msg;
          forwardFFT();
          forwardDone();
        
#line 2085 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_for_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    imsg=0;
    if (imsg < pmeGrid.xBlocks) {
      _slist_2(gen0);
    } else {
      _serial_4(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_for_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    ++imsg;
    if (imsg < pmeGrid.xBlocks) {
      _slist_2(gen0);
    } else {
      _serial_4(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_slist_2(PmeStartMsg* gen0) {
  _when_2(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_slist_2_end(PmeStartMsg* gen0) {
  _for_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilXY::_when_2(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(2, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_3(gen0, static_cast<PmeBlockMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(2);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(2);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_when_2_end(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _slist_2_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_serial_3(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXY_recvDataFromZ()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      { // begin serial block
#line 64 "inc/PmeSolver.ci"

            recvDataFromZ(msg);
          
#line 2185 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_2_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_serial_4(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilXY_backwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 68 "inc/PmeSolver.ci"

          backwardFFT();
          backwardDone();
        
#line 2207 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::startDoneCallback(){
  Closure_PmePencilXY::startDoneCallback_2_closure* genClosure = new Closure_PmePencilXY::startDoneCallback_2_closure();
  startDoneCallback(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::startDoneCallback(Closure_PmePencilXY::startDoneCallback_2_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(0, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::chargeGridReady(PmeRunMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(msg_msg);
  __dep->pushBuffer(1, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_1(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::recvBlock(PmeBlockMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(msg_msg);
  __dep->pushBuffer(2, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(2);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_2(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_sdag_init() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(3,3));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
  __dep->addDepends(2,2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::__sdag_init() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::_sdag_pup(PUP::er &p) {  // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilXY::__sdag_register() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  (void)_sdag_idx_PmePencilXY_initFFT();
  (void)_sdag_idx_PmePencilXY_serial_1();
  (void)_sdag_idx_PmePencilXY_forwardFFT();
  (void)_sdag_idx_PmePencilXY_recvDataFromZ();
  (void)_sdag_idx_PmePencilXY_backwardFFT();
  PUPable_reg(SINGLE_ARG(Closure_PmePencilXY::startDoneCallback_2_closure));
  PUPable_reg(SINGLE_ARG(Closure_PmePencilXY::startDoneCallback_2_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_idx_PmePencilXY_initFFT() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXY_initFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_reg_PmePencilXY_initFFT() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXY_initFFT", NULL, 0, CkIndex_PmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_idx_PmePencilXY_serial_1() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXY_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_reg_PmePencilXY_serial_1() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXY_serial_1", NULL, 0, CkIndex_PmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_idx_PmePencilXY_forwardFFT() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXY_forwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_reg_PmePencilXY_forwardFFT() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXY_forwardFFT", NULL, 0, CkIndex_PmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_idx_PmePencilXY_recvDataFromZ() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXY_recvDataFromZ();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_reg_PmePencilXY_recvDataFromZ() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXY_recvDataFromZ", NULL, 0, CkIndex_PmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_idx_PmePencilXY_backwardFFT() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilXY_backwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilXY::_sdag_reg_PmePencilXY_backwardFFT() { // Potentially missing PmePencilXY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilXY_backwardFFT", NULL, 0, CkIndex_PmePencilXY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: array PmePencilX: ArrayElement{
PmePencilX();
void startDoneCallback();
void chargeGridReady(PmeRunMsg* impl_msg);
void recvBlock(PmeBlockMsg* impl_msg);
void start(PmeStartMsg* impl_msg);
PmePencilX(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilX::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_PmePencilX::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_PmePencilX::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilX::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_PmePencilX::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_PmePencilX::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilX::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilX();
 */
void CProxyElement_PmePencilX::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_PmePencilX::idx_PmePencilX_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxyElement_PmePencilX::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxyElement_PmePencilX::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_chargeGridReady_PmeRunMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxyElement_PmePencilX::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxyElement_PmePencilX::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilX(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilX();
 */
CkArrayID CProxy_PmePencilX::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilX::idx_PmePencilX_void(), opts);
  return gId;
}
void CProxy_PmePencilX::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilX::idx_PmePencilX_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_PmePencilX::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilX::idx_PmePencilX_void(), opts);
  return gId;
}
void CProxy_PmePencilX::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilX::idx_PmePencilX_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_PmePencilX::reg_PmePencilX_void() {
  int epidx = CkRegisterEp("PmePencilX()",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilX_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilX::_call_PmePencilX_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilX* impl_obj = static_cast<PmePencilX*>(impl_obj_void);
  new (impl_obj_void) PmePencilX();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxy_PmePencilX::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilX::idx_startDoneCallback_void(),0);
}

// Entry point registration function
int CkIndex_PmePencilX::reg_startDoneCallback_void() {
  int epidx = CkRegisterEp("startDoneCallback()",
      reinterpret_cast<CkCallFnPtr>(_call_startDoneCallback_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilX::_call_startDoneCallback_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilX* impl_obj = static_cast<PmePencilX*>(impl_obj_void);
  impl_obj->startDoneCallback();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
PUPable_def(SINGLE_ARG(Closure_PmePencilX::startDoneCallback_2_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxy_PmePencilX::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilX::idx_chargeGridReady_PmeRunMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilX::reg_chargeGridReady_PmeRunMsg() {
  int epidx = CkRegisterEp("chargeGridReady(PmeRunMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_chargeGridReady_PmeRunMsg), CMessage_PmeRunMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeRunMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilX::_call_chargeGridReady_PmeRunMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilX* impl_obj = static_cast<PmePencilX*>(impl_obj_void);
  impl_obj->chargeGridReady((PmeRunMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxy_PmePencilX::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilX::idx_recvBlock_PmeBlockMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilX::reg_recvBlock_PmeBlockMsg() {
  int epidx = CkRegisterEp("recvBlock(PmeBlockMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_recvBlock_PmeBlockMsg), CMessage_PmeBlockMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeBlockMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilX::_call_recvBlock_PmeBlockMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilX* impl_obj = static_cast<PmePencilX*>(impl_obj_void);
  impl_obj->recvBlock((PmeBlockMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxy_PmePencilX::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilX::idx_start_PmeStartMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilX::reg_start_PmeStartMsg() {
  int epidx = CkRegisterEp("start(PmeStartMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_start_PmeStartMsg), CMessage_PmeStartMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeStartMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilX::_call_start_PmeStartMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilX* impl_obj = static_cast<PmePencilX*>(impl_obj_void);
  impl_obj->_sdag_fnc_start((PmeStartMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilX(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_PmePencilX::reg_PmePencilX_CkMigrateMessage() {
  int epidx = CkRegisterEp("PmePencilX(CkMigrateMessage* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilX_CkMigrateMessage), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilX::_call_PmePencilX_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<PmePencilX> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilX();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxySection_PmePencilX::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void chargeGridReady(PmeRunMsg* impl_msg);
 */
void CProxySection_PmePencilX::chargeGridReady(PmeRunMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_chargeGridReady_PmeRunMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxySection_PmePencilX::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxySection_PmePencilX::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilX::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilX(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilX::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_ArrayElement::__idx);
  // REG: PmePencilX();
  idx_PmePencilX_void();
  CkRegisterDefaultCtor(__idx, idx_PmePencilX_void());

  // REG: void startDoneCallback();
  idx_startDoneCallback_void();

  // REG: void chargeGridReady(PmeRunMsg* impl_msg);
  idx_chargeGridReady_PmeRunMsg();

  // REG: void recvBlock(PmeBlockMsg* impl_msg);
  idx_recvBlock_PmeBlockMsg();

  // REG: void start(PmeStartMsg* impl_msg);
  idx_start_PmeStartMsg();

  // REG: PmePencilX(CkMigrateMessage* impl_msg);
  idx_PmePencilX_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_PmePencilX_CkMigrateMessage());

  PmePencilX::__sdag_register(); // Potentially missing PmePencilX_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void PmePencilX::start(PmeStartMsg pmeStartMsg){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "PmePencilX", "start(PmeStartMsg pmeStartMsg)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_sdag_fnc_start(PmeStartMsg* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(gen0);
  _slist_0(gen0);
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::start_end(PmeStartMsg* gen0) {
  CmiFree(UsrToEnv(gen0));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_slist_0(PmeStartMsg* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_slist_0_end(PmeStartMsg* gen0) {
  start_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_serial_0(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilX_initFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 81 "inc/PmeSolver.ci"

        initFFT(pmeStartMsg);
        delete pmeStartMsg;
        start(CkCallback(CkIndex_PmePencilX::startDoneCallback(), thisProxy[thisIndex]));
      
#line 2838 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _when_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilX::_when_0(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_1(gen0);
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_when_0_end(PmeStartMsg* gen0) {
  _while_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_serial_1(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilX_serial_1()), CkMyPe(), 0, &projID, this); 
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_while_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_while_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_slist_1(PmeStartMsg* gen0) {
  _when_1(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_slist_1_end(PmeStartMsg* gen0) {
  _while_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilX::_when_1(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, static_cast<PmeRunMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_when_1_end(PmeStartMsg* gen0, PmeRunMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeRunMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _for_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_serial_2(PmeStartMsg* gen0, PmeRunMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilX_forwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeRunMsg*& msg = gen1;
      { // begin serial block
#line 88 "inc/PmeSolver.ci"

          doEnergy = msg->doEnergy;
          doVirial = msg->doVirial;
          lattice = msg->lattice;
          numStrayAtoms = msg->numStrayAtoms;
          delete msg;
          forwardFFT();
          forwardDone();
        
#line 2977 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_for_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    imsg=0;
    if (imsg < pmeGrid.xBlocks) {
      _slist_2(gen0);
    } else {
      _serial_4(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_for_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    ++imsg;
    if (imsg < pmeGrid.xBlocks) {
      _slist_2(gen0);
    } else {
      _serial_4(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_slist_2(PmeStartMsg* gen0) {
  _when_2(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_slist_2_end(PmeStartMsg* gen0) {
  _for_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilX::_when_2(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(2, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_3(gen0, static_cast<PmeBlockMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(2);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(2);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_when_2_end(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _slist_2_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_serial_3(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilX_recvDataFromY()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      { // begin serial block
#line 98 "inc/PmeSolver.ci"

            recvDataFromY(msg);
          
#line 3077 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_2_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_serial_4(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilX_backwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 102 "inc/PmeSolver.ci"

          backwardFFT();
          backwardDone();
        
#line 3099 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::startDoneCallback(){
  Closure_PmePencilX::startDoneCallback_2_closure* genClosure = new Closure_PmePencilX::startDoneCallback_2_closure();
  startDoneCallback(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilX::startDoneCallback(Closure_PmePencilX::startDoneCallback_2_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(0, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilX::chargeGridReady(PmeRunMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(msg_msg);
  __dep->pushBuffer(1, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_1(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilX::recvBlock(PmeBlockMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(msg_msg);
  __dep->pushBuffer(2, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(2);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_2(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_sdag_init() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(3,3));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
  __dep->addDepends(2,2);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::__sdag_init() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilX::_sdag_pup(PUP::er &p) {  // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilX::__sdag_register() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  (void)_sdag_idx_PmePencilX_initFFT();
  (void)_sdag_idx_PmePencilX_serial_1();
  (void)_sdag_idx_PmePencilX_forwardFFT();
  (void)_sdag_idx_PmePencilX_recvDataFromY();
  (void)_sdag_idx_PmePencilX_backwardFFT();
  PUPable_reg(SINGLE_ARG(Closure_PmePencilX::startDoneCallback_2_closure));
  PUPable_reg(SINGLE_ARG(Closure_PmePencilX::startDoneCallback_2_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_idx_PmePencilX_initFFT() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilX_initFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_reg_PmePencilX_initFFT() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilX_initFFT", NULL, 0, CkIndex_PmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_idx_PmePencilX_serial_1() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilX_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_reg_PmePencilX_serial_1() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilX_serial_1", NULL, 0, CkIndex_PmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_idx_PmePencilX_forwardFFT() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilX_forwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_reg_PmePencilX_forwardFFT() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilX_forwardFFT", NULL, 0, CkIndex_PmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_idx_PmePencilX_recvDataFromY() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilX_recvDataFromY();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_reg_PmePencilX_recvDataFromY() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilX_recvDataFromY", NULL, 0, CkIndex_PmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_idx_PmePencilX_backwardFFT() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilX_backwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilX::_sdag_reg_PmePencilX_backwardFFT() { // Potentially missing PmePencilX_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilX_backwardFFT", NULL, 0, CkIndex_PmePencilX::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: array PmePencilY: ArrayElement{
PmePencilY();
void startDoneCallback();
void recvBlock(PmeBlockMsg* impl_msg);
void start(PmeStartMsg* impl_msg);
PmePencilY(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilY::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_PmePencilY::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_PmePencilY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_PmePencilY::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_PmePencilY::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilY::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilY();
 */
void CProxyElement_PmePencilY::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_PmePencilY::idx_PmePencilY_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxyElement_PmePencilY::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilY::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxyElement_PmePencilY::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilY::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxyElement_PmePencilY::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilY::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilY();
 */
CkArrayID CProxy_PmePencilY::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilY::idx_PmePencilY_void(), opts);
  return gId;
}
void CProxy_PmePencilY::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilY::idx_PmePencilY_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_PmePencilY::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilY::idx_PmePencilY_void(), opts);
  return gId;
}
void CProxy_PmePencilY::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilY::idx_PmePencilY_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_PmePencilY::reg_PmePencilY_void() {
  int epidx = CkRegisterEp("PmePencilY()",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilY_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilY::_call_PmePencilY_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilY* impl_obj = static_cast<PmePencilY*>(impl_obj_void);
  new (impl_obj_void) PmePencilY();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxy_PmePencilY::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilY::idx_startDoneCallback_void(),0);
}

// Entry point registration function
int CkIndex_PmePencilY::reg_startDoneCallback_void() {
  int epidx = CkRegisterEp("startDoneCallback()",
      reinterpret_cast<CkCallFnPtr>(_call_startDoneCallback_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilY::_call_startDoneCallback_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilY* impl_obj = static_cast<PmePencilY*>(impl_obj_void);
  impl_obj->startDoneCallback();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
PUPable_def(SINGLE_ARG(Closure_PmePencilY::startDoneCallback_2_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxy_PmePencilY::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilY::idx_recvBlock_PmeBlockMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilY::reg_recvBlock_PmeBlockMsg() {
  int epidx = CkRegisterEp("recvBlock(PmeBlockMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_recvBlock_PmeBlockMsg), CMessage_PmeBlockMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeBlockMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilY::_call_recvBlock_PmeBlockMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilY* impl_obj = static_cast<PmePencilY*>(impl_obj_void);
  impl_obj->recvBlock((PmeBlockMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxy_PmePencilY::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilY::idx_start_PmeStartMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilY::reg_start_PmeStartMsg() {
  int epidx = CkRegisterEp("start(PmeStartMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_start_PmeStartMsg), CMessage_PmeStartMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeStartMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilY::_call_start_PmeStartMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilY* impl_obj = static_cast<PmePencilY*>(impl_obj_void);
  impl_obj->_sdag_fnc_start((PmeStartMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilY(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_PmePencilY::reg_PmePencilY_CkMigrateMessage() {
  int epidx = CkRegisterEp("PmePencilY(CkMigrateMessage* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilY_CkMigrateMessage), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilY::_call_PmePencilY_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<PmePencilY> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilY();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxySection_PmePencilY::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilY::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxySection_PmePencilY::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilY::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxySection_PmePencilY::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilY::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilY(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilY::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_ArrayElement::__idx);
  // REG: PmePencilY();
  idx_PmePencilY_void();
  CkRegisterDefaultCtor(__idx, idx_PmePencilY_void());

  // REG: void startDoneCallback();
  idx_startDoneCallback_void();

  // REG: void recvBlock(PmeBlockMsg* impl_msg);
  idx_recvBlock_PmeBlockMsg();

  // REG: void start(PmeStartMsg* impl_msg);
  idx_start_PmeStartMsg();

  // REG: PmePencilY(CkMigrateMessage* impl_msg);
  idx_PmePencilY_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_PmePencilY_CkMigrateMessage());

  PmePencilY::__sdag_register(); // Potentially missing PmePencilY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void PmePencilY::start(PmeStartMsg pmeStartMsg){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "PmePencilY", "start(PmeStartMsg pmeStartMsg)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_sdag_fnc_start(PmeStartMsg* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(gen0);
  _slist_0(gen0);
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::start_end(PmeStartMsg* gen0) {
  CmiFree(UsrToEnv(gen0));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_0(PmeStartMsg* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_0_end(PmeStartMsg* gen0) {
  start_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_serial_0(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilY_initFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 114 "inc/PmeSolver.ci"

        initFFT(pmeStartMsg);
        delete pmeStartMsg;
        start(CkCallback(CkIndex_PmePencilY::startDoneCallback(), thisProxy[thisIndex]));
      
#line 3673 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _when_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilY::_when_0(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_1(gen0);
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_when_0_end(PmeStartMsg* gen0) {
  _while_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_serial_1(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilY_serial_1()), CkMyPe(), 0, &projID, this); 
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_while_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_while_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_1(PmeStartMsg* gen0) {
  _for_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_1_end(PmeStartMsg* gen0) {
  _while_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_for_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    imsg=0;
    if (imsg < pmeGrid.yBlocks) {
      _slist_2(gen0);
    } else {
      _serial_3(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_for_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    ++imsg;
    if (imsg < pmeGrid.yBlocks) {
      _slist_2(gen0);
    } else {
      _serial_3(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_2(PmeStartMsg* gen0) {
  _when_1(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_2_end(PmeStartMsg* gen0) {
  _for_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilY::_when_1(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, static_cast<PmeBlockMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_when_1_end(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _slist_2_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_serial_2(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilY_recvDataFromX()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      { // begin serial block
#line 122 "inc/PmeSolver.ci"

            doEnergy = msg->doEnergy;
            doVirial = msg->doVirial;
            lattice = msg->lattice;
            numStrayAtoms += msg->numStrayAtoms;
            recvDataFromX(msg);
          
#line 3854 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_serial_3(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilY_forwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 130 "inc/PmeSolver.ci"

          forwardFFT();
          forwardDone();
          numStrayAtoms = 0;
        
#line 3877 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _for_1(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_for_1(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    imsg=0;
    if (imsg < pmeGrid.yBlocks) {
      _slist_3(gen0);
    } else {
      _serial_5(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_for_1_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    ++imsg;
    if (imsg < pmeGrid.yBlocks) {
      _slist_3(gen0);
    } else {
      _serial_5(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_3(PmeStartMsg* gen0) {
  _when_2(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_slist_3_end(PmeStartMsg* gen0) {
  _for_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilY::_when_2(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_4(gen0, static_cast<PmeBlockMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(2);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_when_2_end(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _slist_3_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_serial_4(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilY_recvDataFromZ()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      { // begin serial block
#line 136 "inc/PmeSolver.ci"

            recvDataFromZ(msg);
          
#line 3976 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_2_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_serial_5(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilY_backwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 140 "inc/PmeSolver.ci"

          backwardFFT();
          backwardDone();
        
#line 3998 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::startDoneCallback(){
  Closure_PmePencilY::startDoneCallback_2_closure* genClosure = new Closure_PmePencilY::startDoneCallback_2_closure();
  startDoneCallback(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilY::startDoneCallback(Closure_PmePencilY::startDoneCallback_2_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(0, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilY::recvBlock(PmeBlockMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(msg_msg);
  __dep->pushBuffer(1, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    switch(c->whenID) {
    case 1:
      _when_1(
        static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
      );
    break;
    case 2:
      _when_2(
        static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
      );
    break;
    }
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_sdag_init() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(2,3));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
  __dep->addDepends(2,1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::__sdag_init() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilY::_sdag_pup(PUP::er &p) {  // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilY::__sdag_register() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  (void)_sdag_idx_PmePencilY_initFFT();
  (void)_sdag_idx_PmePencilY_serial_1();
  (void)_sdag_idx_PmePencilY_recvDataFromX();
  (void)_sdag_idx_PmePencilY_forwardFFT();
  (void)_sdag_idx_PmePencilY_recvDataFromZ();
  (void)_sdag_idx_PmePencilY_backwardFFT();
  PUPable_reg(SINGLE_ARG(Closure_PmePencilY::startDoneCallback_2_closure));
  PUPable_reg(SINGLE_ARG(Closure_PmePencilY::startDoneCallback_2_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_idx_PmePencilY_initFFT() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilY_initFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_reg_PmePencilY_initFFT() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilY_initFFT", NULL, 0, CkIndex_PmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_idx_PmePencilY_serial_1() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilY_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_reg_PmePencilY_serial_1() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilY_serial_1", NULL, 0, CkIndex_PmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_idx_PmePencilY_recvDataFromX() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilY_recvDataFromX();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_reg_PmePencilY_recvDataFromX() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilY_recvDataFromX", NULL, 0, CkIndex_PmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_idx_PmePencilY_forwardFFT() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilY_forwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_reg_PmePencilY_forwardFFT() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilY_forwardFFT", NULL, 0, CkIndex_PmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_idx_PmePencilY_recvDataFromZ() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilY_recvDataFromZ();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_reg_PmePencilY_recvDataFromZ() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilY_recvDataFromZ", NULL, 0, CkIndex_PmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_idx_PmePencilY_backwardFFT() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilY_backwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilY::_sdag_reg_PmePencilY_backwardFFT() { // Potentially missing PmePencilY_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilY_backwardFFT", NULL, 0, CkIndex_PmePencilY::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



/* DEFS: array PmePencilZ: ArrayElement{
PmePencilZ();
void startDoneCallback();
void recvBlock(PmeBlockMsg* impl_msg);
void skip();
void start(PmeStartMsg* impl_msg);
PmePencilZ(CkMigrateMessage* impl_msg);
};
 */
#ifndef CK_TEMPLATES_ONLY
 int CkIndex_PmePencilZ::__idx=0;
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CProxySection_PmePencilZ::contribute(CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, userData, fragSize);
}

void CProxySection_PmePencilZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, userData, fragSize);
}

void CProxySection_PmePencilZ::contribute(CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(sid, cb, userData, fragSize);
}

void CProxySection_PmePencilZ::contribute(int dataSize,void *data,CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(dataSize, data, type, sid, cb, userData, fragSize);
}

template <typename T>
void CProxySection_PmePencilZ::contribute(std::vector<T> &data, CkReduction::reducerType type, CkSectionInfo &sid, const CkCallback &cb, int userData, int fragSize)
{
   CkArray *ckarr = CProxy_CkArray(sid.get_aid()).ckLocalBranch();
   CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(ckarr->getmCastMgr()).ckLocalBranch();
   mCastGrp->contribute(data, type, sid, cb, userData, fragSize);
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilZ();
 */
void CProxyElement_PmePencilZ::insert(int onPE, const CkEntryOptions *impl_e_opts)
{ 
   void *impl_msg = CkAllocSysMsg(impl_e_opts);
   UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
   ckInsert((CkArrayMessage *)impl_msg,CkIndex_PmePencilZ::idx_PmePencilZ_void(),onPE);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxyElement_PmePencilZ::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxyElement_PmePencilZ::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void skip();
 */
void CProxyElement_PmePencilZ::skip(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_skip_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxyElement_PmePencilZ::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilZ();
 */
CkArrayID CProxy_PmePencilZ::ckNew(const CkArrayOptions &opts, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilZ::idx_PmePencilZ_void(), opts);
  return gId;
}
void CProxy_PmePencilZ::ckNew(const CkArrayOptions &opts, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilZ::idx_PmePencilZ_void(), _ck_array_creation_cb, opts, impl_msg);
}
CkArrayID CProxy_PmePencilZ::ckNew(const int s1, const int s2, const int s3, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkArrayID gId = ckCreateArray((CkArrayMessage *)impl_msg, CkIndex_PmePencilZ::idx_PmePencilZ_void(), opts);
  return gId;
}
void CProxy_PmePencilZ::ckNew(const int s1, const int s2, const int s3, CkCallback _ck_array_creation_cb, const CkEntryOptions *impl_e_opts)
{
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  CkArrayOptions opts(s1, s2, s3);
  UsrToEnv(impl_msg)->setMsgtype(ArrayEltInitMsg);
  CkSendAsyncCreateArray(CkIndex_PmePencilZ::idx_PmePencilZ_void(), _ck_array_creation_cb, opts, impl_msg);
}

// Entry point registration function
int CkIndex_PmePencilZ::reg_PmePencilZ_void() {
  int epidx = CkRegisterEp("PmePencilZ()",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilZ_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilZ::_call_PmePencilZ_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilZ* impl_obj = static_cast<PmePencilZ*>(impl_obj_void);
  new (impl_obj_void) PmePencilZ();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxy_PmePencilZ::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilZ::idx_startDoneCallback_void(),0);
}

// Entry point registration function
int CkIndex_PmePencilZ::reg_startDoneCallback_void() {
  int epidx = CkRegisterEp("startDoneCallback()",
      reinterpret_cast<CkCallFnPtr>(_call_startDoneCallback_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilZ::_call_startDoneCallback_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilZ* impl_obj = static_cast<PmePencilZ*>(impl_obj_void);
  impl_obj->startDoneCallback();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
PUPable_def(SINGLE_ARG(Closure_PmePencilZ::startDoneCallback_2_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxy_PmePencilZ::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilZ::idx_recvBlock_PmeBlockMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilZ::reg_recvBlock_PmeBlockMsg() {
  int epidx = CkRegisterEp("recvBlock(PmeBlockMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_recvBlock_PmeBlockMsg), CMessage_PmeBlockMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeBlockMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilZ::_call_recvBlock_PmeBlockMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilZ* impl_obj = static_cast<PmePencilZ*>(impl_obj_void);
  impl_obj->recvBlock((PmeBlockMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void skip();
 */
void CProxy_PmePencilZ::skip(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilZ::idx_skip_void(),0);
}

// Entry point registration function
int CkIndex_PmePencilZ::reg_skip_void() {
  int epidx = CkRegisterEp("skip()",
      reinterpret_cast<CkCallFnPtr>(_call_skip_void), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilZ::_call_skip_void(void* impl_msg, void* impl_obj_void)
{
  PmePencilZ* impl_obj = static_cast<PmePencilZ*>(impl_obj_void);
  impl_obj->skip();
  if(UsrToEnv(impl_msg)->isVarSysMsg() == 0)
    CkFreeSysMsg(impl_msg);
}
PUPable_def(SINGLE_ARG(Closure_PmePencilZ::skip_4_closure))
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxy_PmePencilZ::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckBroadcast(impl_amsg, CkIndex_PmePencilZ::idx_start_PmeStartMsg(),0);
}

// Entry point registration function
int CkIndex_PmePencilZ::reg_start_PmeStartMsg() {
  int epidx = CkRegisterEp("start(PmeStartMsg* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_start_PmeStartMsg), CMessage_PmeStartMsg::__idx, __idx, 0);
  CkRegisterMessagePupFn(epidx, (CkMessagePupFn)PmeStartMsg::ckDebugPup);
  return epidx;
}

void CkIndex_PmePencilZ::_call_start_PmeStartMsg(void* impl_msg, void* impl_obj_void)
{
  PmePencilZ* impl_obj = static_cast<PmePencilZ*>(impl_obj_void);
  impl_obj->_sdag_fnc_start((PmeStartMsg*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilZ(CkMigrateMessage* impl_msg);
 */

// Entry point registration function
int CkIndex_PmePencilZ::reg_PmePencilZ_CkMigrateMessage() {
  int epidx = CkRegisterEp("PmePencilZ(CkMigrateMessage* impl_msg)",
      reinterpret_cast<CkCallFnPtr>(_call_PmePencilZ_CkMigrateMessage), 0, __idx, 0);
  return epidx;
}

void CkIndex_PmePencilZ::_call_PmePencilZ_CkMigrateMessage(void* impl_msg, void* impl_obj_void)
{
  call_migration_constructor<PmePencilZ> c = impl_obj_void;
  c((CkMigrateMessage*)impl_msg);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilZ();
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void startDoneCallback();
 */
void CProxySection_PmePencilZ::startDoneCallback(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_startDoneCallback_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void recvBlock(PmeBlockMsg* impl_msg);
 */
void CProxySection_PmePencilZ::recvBlock(PmeBlockMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_recvBlock_PmeBlockMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void skip();
 */
void CProxySection_PmePencilZ::skip(const CkEntryOptions *impl_e_opts) 
{
  ckCheck();
  void *impl_msg = CkAllocSysMsg(impl_e_opts);
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_skip_void(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: void start(PmeStartMsg* impl_msg);
 */
void CProxySection_PmePencilZ::start(PmeStartMsg* impl_msg) 
{
  ckCheck();
  UsrToEnv(impl_msg)->setMsgtype(ForArrayEltMsg);
  CkArrayMessage *impl_amsg=(CkArrayMessage *)impl_msg;
  impl_amsg->array_setIfNotThere(CkArray_IfNotThere_buffer);
  ckSend(impl_amsg, CkIndex_PmePencilZ::idx_start_PmeStartMsg(),0);
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
/* DEFS: PmePencilZ(CkMigrateMessage* impl_msg);
 */
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void CkIndex_PmePencilZ::__register(const char *s, size_t size) {
  __idx = CkRegisterChare(s, size, TypeArray);
  CkRegisterArrayDimensions(__idx, 3);
  CkRegisterBase(__idx, CkIndex_ArrayElement::__idx);
  // REG: PmePencilZ();
  idx_PmePencilZ_void();
  CkRegisterDefaultCtor(__idx, idx_PmePencilZ_void());

  // REG: void startDoneCallback();
  idx_startDoneCallback_void();

  // REG: void recvBlock(PmeBlockMsg* impl_msg);
  idx_recvBlock_PmeBlockMsg();

  // REG: void skip();
  idx_skip_void();

  // REG: void start(PmeStartMsg* impl_msg);
  idx_start_PmeStartMsg();

  // REG: PmePencilZ(CkMigrateMessage* impl_msg);
  idx_PmePencilZ_CkMigrateMessage();
  CkRegisterMigCtor(__idx, idx_PmePencilZ_CkMigrateMessage());

  PmePencilZ::__sdag_register(); // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */

#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::start(PmeStartMsg pmeStartMsg){
  CkPrintf("Error> Direct call to SDAG entry method \'%s::%s\'!\n", "PmePencilZ", "start(PmeStartMsg pmeStartMsg)"); 
  CkAbort("Direct SDAG call is not allowed for SDAG entry methods having when constructs. Call such SDAG methods using a proxy"); 
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_sdag_fnc_start(PmeStartMsg* gen0) {
  _TRACE_END_EXECUTE(); 
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(gen0);
  _slist_0(gen0);
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::start_end(PmeStartMsg* gen0) {
  CmiFree(UsrToEnv(gen0));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_slist_0(PmeStartMsg* gen0) {
  _serial_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_slist_0_end(PmeStartMsg* gen0) {
  start_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_serial_0(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilZ_initFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 153 "inc/PmeSolver.ci"

        initFFT(pmeStartMsg);
        delete pmeStartMsg;
        start(CkCallback(CkIndex_PmePencilZ::startDoneCallback(), thisProxy[thisIndex]));
      
#line 4641 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _when_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilZ::_when_0(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(0, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_1(gen0);
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(0);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(0);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_when_0_end(PmeStartMsg* gen0) {
  _while_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_serial_1(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilZ_serial_1()), CkMyPe(), 0, &projID, this); 
  _TRACE_END_EXECUTE(); 
  _when_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_while_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_while_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    if (true) {
      _slist_1(gen0);
    } else {
      _slist_0_end(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_slist_1(PmeStartMsg* gen0) {
  _for_0(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_slist_1_end(PmeStartMsg* gen0) {
  _while_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_for_0(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    imsg=0;
    if (imsg < pmeGrid.zBlocks) {
      _slist_2(gen0);
    } else {
      _serial_3(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_for_0_end(PmeStartMsg* gen0) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    ++imsg;
    if (imsg < pmeGrid.zBlocks) {
      _slist_2(gen0);
    } else {
      _serial_3(gen0);
    }
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_slist_2(PmeStartMsg* gen0) {
  _when_1(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_slist_2_end(PmeStartMsg* gen0) {
  _for_0_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
SDAG::Continuation* PmePencilZ::_when_1(PmeStartMsg* gen0) {
  SDAG::Buffer* buf0 = __dep->tryFindMessage(1, false, 0, 0);
  if (buf0) {
    __dep->removeMessage(buf0);
    _serial_2(gen0, static_cast<PmeBlockMsg*>(static_cast<SDAG::MsgClosure*>(buf0->cl)->msg));
    delete buf0;
    return 0;
  } else {
    SDAG::Continuation* c = new SDAG::Continuation(1);
    c->addClosure(new SDAG::MsgClosure(gen0));
    c->anyEntries.push_back(1);
    __dep->reg(c);
    return c;
  }
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_when_1_end(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      CmiFree(UsrToEnv(msg));
    }
  }
  _slist_2_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_serial_2(PmeStartMsg* gen0, PmeBlockMsg* gen1) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilZ_recvDataFromY()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    {
      PmeBlockMsg*& msg = gen1;
      { // begin serial block
#line 161 "inc/PmeSolver.ci"

            doEnergy = msg->doEnergy;
            doVirial = msg->doVirial;
            lattice = msg->lattice;
            numStrayAtoms += msg->numStrayAtoms;
            recvDataFromY(msg);
          
#line 4822 "PmeSolver.def.h"
      } // end serial block
    }
  }
  _TRACE_END_EXECUTE(); 
  _when_1_end(gen0, gen1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_serial_3(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilZ_forwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 169 "inc/PmeSolver.ci"

          forwardFFT();
          forwardDone();
        
#line 4844 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_4(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_serial_4(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilZ_backwardFFT()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 173 "inc/PmeSolver.ci"
 backwardFFT(); 
#line 4862 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _serial_5(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_serial_5(PmeStartMsg* gen0) {
  CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
  _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, (_sdag_idx_PmePencilZ_backwardDone()), CkMyPe(), 0, &projID, this); 
  {
    PmeStartMsg*& pmeStartMsg = gen0;
    { // begin serial block
#line 174 "inc/PmeSolver.ci"
 backwardDone(); 
#line 4880 "PmeSolver.def.h"
    } // end serial block
  }
  _TRACE_END_EXECUTE(); 
  _slist_1_end(gen0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::startDoneCallback(){
  Closure_PmePencilZ::startDoneCallback_2_closure* genClosure = new Closure_PmePencilZ::startDoneCallback_2_closure();
  startDoneCallback(genClosure);
  genClosure->deref();
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::startDoneCallback(Closure_PmePencilZ::startDoneCallback_2_closure* genClosure){
  if (!__dep.get()) _sdag_init();
  __dep->pushBuffer(0, genClosure);
  SDAG::Continuation* c = __dep->tryFindContinuation(0);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_0(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::recvBlock(PmeBlockMsg* msg_msg){
  if (!__dep.get()) _sdag_init();
  CkReferenceMsg(msg_msg);
  __dep->pushBuffer(1, new SDAG::MsgClosure(msg_msg));
  SDAG::Continuation* c = __dep->tryFindContinuation(1);
  if (c) {
    _TRACE_END_EXECUTE(); 
    _when_1(
      static_cast<PmeStartMsg*>(static_cast<SDAG::MsgClosure*>(c->closure[0])->msg)
    );
    CmiObjId projID = this->ckGetArrayIndex().getProjectionID();
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _sdagEP, CkMyPe(), 0, &projID, this); 
    delete c;
  }
}

#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_sdag_init() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  __dep.reset(new SDAG::Dependency(2,2));
  __dep->addDepends(0,0);
  __dep->addDepends(1,1);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::__sdag_init() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::_sdag_pup(PUP::er &p) {  // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  p|__dep;
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
void PmePencilZ::__sdag_register() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  (void)_sdag_idx_PmePencilZ_initFFT();
  (void)_sdag_idx_PmePencilZ_serial_1();
  (void)_sdag_idx_PmePencilZ_recvDataFromY();
  (void)_sdag_idx_PmePencilZ_forwardFFT();
  (void)_sdag_idx_PmePencilZ_backwardFFT();
  (void)_sdag_idx_PmePencilZ_backwardDone();
  PUPable_reg(SINGLE_ARG(Closure_PmePencilZ::startDoneCallback_2_closure));
  PUPable_reg(SINGLE_ARG(Closure_PmePencilZ::skip_4_closure));
  PUPable_reg(SINGLE_ARG(Closure_PmePencilZ::startDoneCallback_2_closure));
  PUPable_reg(SINGLE_ARG(Closure_PmePencilZ::skip_4_closure));
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_idx_PmePencilZ_initFFT() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilZ_initFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_reg_PmePencilZ_initFFT() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilZ_initFFT", NULL, 0, CkIndex_PmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_idx_PmePencilZ_serial_1() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilZ_serial_1();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_reg_PmePencilZ_serial_1() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilZ_serial_1", NULL, 0, CkIndex_PmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_idx_PmePencilZ_recvDataFromY() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilZ_recvDataFromY();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_reg_PmePencilZ_recvDataFromY() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilZ_recvDataFromY", NULL, 0, CkIndex_PmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_idx_PmePencilZ_forwardFFT() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilZ_forwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_reg_PmePencilZ_forwardFFT() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilZ_forwardFFT", NULL, 0, CkIndex_PmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_idx_PmePencilZ_backwardFFT() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilZ_backwardFFT();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_reg_PmePencilZ_backwardFFT() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilZ_backwardFFT", NULL, 0, CkIndex_PmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_idx_PmePencilZ_backwardDone() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  static int epidx = _sdag_reg_PmePencilZ_backwardDone();
  return epidx;
}
#endif /* CK_TEMPLATES_ONLY */


#ifndef CK_TEMPLATES_ONLY
int PmePencilZ::_sdag_reg_PmePencilZ_backwardDone() { // Potentially missing PmePencilZ_SDAG_CODE in your class definition?
  return CkRegisterEp("PmePencilZ_backwardDone", NULL, 0, CkIndex_PmePencilZ::__idx, 0);
}
#endif /* CK_TEMPLATES_ONLY */



#ifndef CK_TEMPLATES_ONLY
void _registerPmeSolver(void)
{
  static int _done = 0; if(_done) return; _done = 1;
/* REG: message PmeStartMsg;
*/
CMessage_PmeStartMsg::__register("PmeStartMsg", sizeof(PmeStartMsg),(CkPackFnPtr) PmeStartMsg::pack,(CkUnpackFnPtr) PmeStartMsg::unpack);

/* REG: message PmeRunMsg;
*/
CMessage_PmeRunMsg::__register("PmeRunMsg", sizeof(PmeRunMsg),(CkPackFnPtr) PmeRunMsg::pack,(CkUnpackFnPtr) PmeRunMsg::unpack);

/* REG: message PmeDoneMsg;
*/
CMessage_PmeDoneMsg::__register("PmeDoneMsg", sizeof(PmeDoneMsg),(CkPackFnPtr) PmeDoneMsg::pack,(CkUnpackFnPtr) PmeDoneMsg::unpack);

/* REG: group PmePencilXYZMap: CkArrayMap{
PmePencilXYZMap(int pe);
};
*/
  CkIndex_PmePencilXYZMap::__register("PmePencilXYZMap", sizeof(PmePencilXYZMap));

/* REG: group PmePencilXMap: CkArrayMap{
PmePencilXMap(int ia, int ib, int width, const std::vector<int> &pes);
};
*/
  CkIndex_PmePencilXMap::__register("PmePencilXMap", sizeof(PmePencilXMap));

/* REG: group PmePencilXYMap: CkArrayMap{
PmePencilXYMap(const std::vector<int> &pes);
};
*/
  CkIndex_PmePencilXYMap::__register("PmePencilXYMap", sizeof(PmePencilXYMap));

/* REG: array PmePencilXYZ: ArrayElement{
PmePencilXYZ();
void chargeGridReady(PmeRunMsg* impl_msg);
void skip();
void start(PmeStartMsg* impl_msg);
PmePencilXYZ(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_PmePencilXYZ::__register("PmePencilXYZ", sizeof(PmePencilXYZ));

/* REG: message PmeBlockMsg{
float2 data[];
}
;
*/
CMessage_PmeBlockMsg::__register("PmeBlockMsg", sizeof(PmeBlockMsg),(CkPackFnPtr) PmeBlockMsg::pack,(CkUnpackFnPtr) PmeBlockMsg::unpack);

/* REG: array PmePencilXY: ArrayElement{
PmePencilXY();
void startDoneCallback();
void chargeGridReady(PmeRunMsg* impl_msg);
void recvBlock(PmeBlockMsg* impl_msg);
void start(PmeStartMsg* impl_msg);
PmePencilXY(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_PmePencilXY::__register("PmePencilXY", sizeof(PmePencilXY));

/* REG: array PmePencilX: ArrayElement{
PmePencilX();
void startDoneCallback();
void chargeGridReady(PmeRunMsg* impl_msg);
void recvBlock(PmeBlockMsg* impl_msg);
void start(PmeStartMsg* impl_msg);
PmePencilX(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_PmePencilX::__register("PmePencilX", sizeof(PmePencilX));

/* REG: array PmePencilY: ArrayElement{
PmePencilY();
void startDoneCallback();
void recvBlock(PmeBlockMsg* impl_msg);
void start(PmeStartMsg* impl_msg);
PmePencilY(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_PmePencilY::__register("PmePencilY", sizeof(PmePencilY));

/* REG: array PmePencilZ: ArrayElement{
PmePencilZ();
void startDoneCallback();
void recvBlock(PmeBlockMsg* impl_msg);
void skip();
void start(PmeStartMsg* impl_msg);
PmePencilZ(CkMigrateMessage* impl_msg);
};
*/
  CkIndex_PmePencilZ::__register("PmePencilZ", sizeof(PmePencilZ));

}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilXYZMap::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilXYZMap>(dynamic_cast<PmePencilXYZMap*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilXMap::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilXMap>(dynamic_cast<PmePencilXMap*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilXYMap::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilXYMap>(dynamic_cast<PmePencilXYMap*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilXYZ::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilXYZ>(dynamic_cast<PmePencilXYZ*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilXY::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilXY>(dynamic_cast<PmePencilXY*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilX::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilX>(dynamic_cast<PmePencilX*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilY::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilY>(dynamic_cast<PmePencilY*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
#ifndef CK_TEMPLATES_ONLY
template <>
void CBase_PmePencilZ::virtual_pup(PUP::er &p) {
    recursive_pup<PmePencilZ>(dynamic_cast<PmePencilZ*>(this), p);
}
#endif /* CK_TEMPLATES_ONLY */
